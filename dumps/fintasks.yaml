apiVersion: v1
items:
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"build-and-push","namespace":"tekton-pipelines"},"spec":{"params":[{"default":".","description":"the context dir within source","name":"contextDir"},{"default":"https://repo.maven.apache.org/maven2/","description":"the maven mirrror url","name":"mavenMirrorUrl"},{"default":"$(outputs.resources.builtImage.url)","description":"the fully qualified image name","name":"destinationImage"},{"default":"Dockerfile","description":"the docker file to used for building the application","name":"dockerFile"},{"default":"false","description":"tls verify","name":"tlsVerify","type":"string"}],"resources":{"inputs":[{"name":"source","type":"git"}],"outputs":[{"name":"builtImage","type":"image"}]},"steps":[{"args":["-s","$(workspaces.maven-settings.path)/settings.xml","-DskipTests","clean","install"],"command":["mvn"],"env":[{"name":"user.home","value":"/home/tekton"}],"image":"docker.io/maven:3.6.3-openjdk-11-slim","name":"build-sources","workingDir":"/workspace/source/$(inputs.params.contextDir)"},{"args":["--insecure","--dockerfile=$(inputs.params.dockerFile)\"","--destination=$(inputs.params.destinationImage)\""],"command":["/kaniko/executor"],"env":[{"name":"DOCKER_CONFIG","value":"/tekton/home/.docker/"}],"image":"gcr.io/kaniko-project/executor:v0.17.1","name":"build-image-and-push","securityContext":{"privileged":true,"runAsUser":0},"workingDir":"/workspace/source/"}],"workspaces":[{"name":"maven-settings"},{"name":"source"}]}}
    creationTimestamp: "2021-07-08T19:56:01Z"
    generation: 1
    name: build-and-push
    namespace: tekton-pipelines
    resourceVersion: "24483297"
    uid: 724a21bf-b7bd-4b93-aba1-acc1593663c0
  spec:
    params:
    - default: .
      description: the context dir within source
      name: contextDir
      type: string
    - default: https://repo.maven.apache.org/maven2/
      description: the maven mirrror url
      name: mavenMirrorUrl
      type: string
    - default: $(outputs.resources.builtImage.url)
      description: the fully qualified image name
      name: destinationImage
      type: string
    - default: Dockerfile
      description: the docker file to used for building the application
      name: dockerFile
      type: string
    - default: "false"
      description: tls verify
      name: tlsVerify
      type: string
    resources:
      inputs:
      - name: source
        type: git
      outputs:
      - name: builtImage
        type: image
    steps:
    - args:
      - -s
      - $(workspaces.maven-settings.path)/settings.xml
      - -DskipTests
      - clean
      - install
      command:
      - mvn
      env:
      - name: user.home
        value: /home/tekton
      image: docker.io/maven:3.6.3-openjdk-11-slim
      name: build-sources
      resources: {}
      workingDir: /workspace/source/$(inputs.params.contextDir)
    - args:
      - --insecure
      - --dockerfile=$(inputs.params.dockerFile)"
      - --destination=$(inputs.params.destinationImage)"
      command:
      - /kaniko/executor
      env:
      - name: DOCKER_CONFIG
        value: /tekton/home/.docker/
      image: gcr.io/kaniko-project/executor:v0.17.1
      name: build-image-and-push
      resources: {}
      securityContext:
        privileged: true
        runAsUser: 0
      workingDir: /workspace/source/
    workspaces:
    - name: maven-settings
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"build-app","namespace":"tekton-pipelines"},"spec":{"params":[{"default":".","description":"the context dir within source","name":"contextDir"},{"default":"https://repo.maven.apache.org/maven2/","description":"the maven mirrror url","name":"mavenMirrorUrl"},{"default":"$(outputs.resources.builtImage.url):$(outputs.results.build-id)","description":"the fully qualified image name","name":"destinationImage"},{"default":"Dockerfile","description":"the docker file to used for building the application","name":"dockerFile"},{"default":"false","description":"tls verify","name":"tlsVerify","type":"string"}],"resources":{"inputs":[{"name":"source","type":"git"}],"outputs":[{"name":"builtImage","type":"image"}]},"results":[{"description":"Current timestamp","name":"timestamp"},{"description":"ID of the current build","name":"build-id"}],"steps":[{"args":["-s","$(workspaces.maven-settings.path)/settings.xml","-DskipTests","clean","install"],"command":["mvn"],"env":[{"name":"user.home","value":"/home/tekton"}],"image":"docker.io/maven:3.6.3-openjdk-11-slim","name":"build-sources","workingDir":"/workspace/source/$(inputs.params.contextDir)"},{"image":"bitnami/minideb","name":"get-timestamp","script":"#!/usr/bin/env bash\nts=`date \"+%Y%m%d%H%M\"`\necho \"Current Timestamp: ${ts}\"\necho ${ts} | tr -d \"\\n\" | tee $(results.timestamp.path)\n"},{"image":"bitnami/minideb","name":"get-buildid","script":"#!/usr/bin/env bash\nts=`cat $(results.timestamp.path)`\nbuildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?\u003c=\u003cversion\u003e).*(?=\\-SNAPSHOT\u003c/version\u003e)')-${ts}\necho ${buildId} | tr -d \"\\n\" | tee $(results.build-id.path)\n","workingDir":"/workspace/source/$(inputs.params.contextDir)"},{"args":["bud","--layers","-f","$(inputs.params.dockerFile)","-t","$(inputs.params.destinationImage)","."],"command":["buildah"],"image":"buildah/buildah","name":"build-image","securityContext":{"privileged":true,"runAsUser":0},"volumeMounts":[{"mountPath":"/var/lib/containers","name":"varlibc"}],"workingDir":"/workspace/source/"},{"args":["push","--tls-verify=$(inputs.params.tlsVerify)","$(inputs.params.destinationImage)","docker://$(inputs.params.destinationImage)"],"command":["buildah"],"image":"buildah/buildah","name":"push-image","securityContext":{"privileged":true,"runAsUser":0},"volumeMounts":[{"mountPath":"/var/lib/containers","name":"varlibc"}],"workingDir":"/workspace/source/"},{"args":["-c","ls -A1 | xargs rm -rf"],"command":["bash"],"image":"nexus.l21d31708530003.local:5000/minideb","name":"clean-up","workingDir":"/workspace/source/"}],"volumes":[{"emptyDir":{},"name":"varlibc"}],"workspaces":[{"name":"maven-settings"}]}}
    creationTimestamp: "2021-07-06T16:02:08Z"
    generation: 60
    name: build-app
    namespace: tekton-pipelines
    resourceVersion: "25850725"
    uid: bbba7e37-0fc2-4fca-9162-9a5161bc9a05
  spec:
    params:
    - default: .
      description: the context dir within source
      name: contextDir
      type: string
    - default: https://repo.maven.apache.org/maven2/
      description: the maven mirrror url
      name: mavenMirrorUrl
      type: string
    - default: $(outputs.resources.builtImage.url):$(outputs.results.build-id)
      description: the fully qualified image name
      name: destinationImage
      type: string
    - default: Dockerfile
      description: the docker file to used for building the application
      name: dockerFile
      type: string
    - default: "false"
      description: tls verify
      name: tlsVerify
      type: string
    resources:
      inputs:
      - name: source
        type: git
      outputs:
      - name: builtImage
        type: image
    results:
    - description: Current timestamp
      name: timestamp
    - description: ID of the current build
      name: build-id
    steps:
    - args:
      - -s
      - $(workspaces.maven-settings.path)/settings.xml
      - -DskipTests
      - clean
      - install
      command:
      - mvn
      env:
      - name: user.home
        value: /home/tekton
      image: docker.io/maven:3.6.3-openjdk-11-slim
      name: build-sources
      resources: {}
      workingDir: /workspace/source/$(inputs.params.contextDir)
    - image: bitnami/minideb
      name: get-timestamp
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`date "+%Y%m%d%H%M"`
        echo "Current Timestamp: ${ts}"
        echo ${ts} | tr -d "\n" | tee $(results.timestamp.path)
    - image: bitnami/minideb
      name: get-buildid
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`cat $(results.timestamp.path)`
        buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?<=<version>).*(?=\-SNAPSHOT</version>)')-${ts}
        echo ${buildId} | tr -d "\n" | tee $(results.build-id.path)
      workingDir: /workspace/source/$(inputs.params.contextDir)
    - args:
      - bud
      - --layers
      - -f
      - $(inputs.params.dockerFile)
      - -t
      - $(inputs.params.destinationImage)
      - .
      command:
      - buildah
      image: buildah/buildah
      name: build-image
      resources: {}
      securityContext:
        privileged: true
        runAsUser: 0
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibc
      workingDir: /workspace/source/
    - args:
      - push
      - --tls-verify=$(inputs.params.tlsVerify)
      - $(inputs.params.destinationImage)
      - docker://$(inputs.params.destinationImage)
      command:
      - buildah
      image: buildah/buildah
      name: push-image
      resources: {}
      securityContext:
        privileged: true
        runAsUser: 0
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibc
      workingDir: /workspace/source/
    - args:
      - -c
      - ls -A1 | xargs rm -rf
      command:
      - bash
      image: nexus.l21d31708530003.local:5000/minideb
      name: clean-up
      resources: {}
      workingDir: /workspace/source/
    volumes:
    - emptyDir: {}
      name: varlibc
    workspaces:
    - name: maven-settings
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"build-type-check","namespace":"tekton-pipelines"},"spec":{"params":[{"default":".","name":"CONTEXT","type":"string"}],"results":[{"description":"check if true springboot repo","name":"standalone-check"},{"description":"check if true shared repo","name":"shared-check"},{"description":"check if true library repo","name":"library-check"},{"description":"check if true nodejs repo","name":"nodejs-check"},{"description":"chart-template nodejs or springboot","name":"chart-template"}],"steps":[{"image":"alpine","name":"springboot-check","script":"#!/usr/bin/env sh\nset -x\nif test -d \"$(workspaces.source.path)/$(params.CONTEXT)/standalone\"; then\n  printf standalone | tee \"$(results.standalone-check.path)\" \u0026\u0026 printf charts/limits-template-novault \u003e \"$(results.chart-template.path)\"\nelse\n  printf no | tee \"$(results.standalone-check.path)\"\nfi\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT)"},{"image":"alpine","name":"library-check","script":"#!/usr/bin/env sh\nset -x\nif test -d \"$(workspaces.source.path)/$(params.CONTEXT)/shared\"; then\n  printf shared | tee \"$(results.shared-check.path)\"\nelse\n  if test -f \"$(workspaces.source.path)/$(params.CONTEXT)/pom.xml\"; then\n    printf . | tee \"$(results.shared-check.path)\"\n  else\n    printf no | tee \"$(results.shared-check.path)\"\n  fi\nfi\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT)"},{"image":"alpine","name":"nodejs-check","script":"#!/usr/bin/env sh\nset -x\nif test -f \"$(workspaces.source.path)/$(params.CONTEXT)/package.json\"; then\n  printf . | tee \"$(results.nodejs-check.path)\" \u0026\u0026 printf charts/limits-template-nodejs \u003e \"$(results.chart-template.path)\"\nelse\n  printf no | tee \"$(results.nodejs-check.path)\"\nfi\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT)"}],"workspaces":[{"description":"project code","name":"source"}]}}
    creationTimestamp: "2021-07-29T23:21:23Z"
    generation: 2
    name: build-type-check
    namespace: tekton-pipelines
    resourceVersion: "41916276"
    uid: 92fe2993-db21-4829-84f9-87b37a3ffc7d
  spec:
    params:
    - default: .
      name: CONTEXT
      type: string
    results:
    - description: check if true springboot repo
      name: standalone-check
    - description: check if true shared repo
      name: shared-check
    - description: check if true library repo
      name: library-check
    - description: check if true nodejs repo
      name: nodejs-check
    - description: chart-template nodejs or springboot
      name: chart-template
    steps:
    - image: alpine
      name: springboot-check
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -x
        if test -d "$(workspaces.source.path)/$(params.CONTEXT)/standalone"; then
          printf standalone | tee "$(results.standalone-check.path)" && printf charts/limits-template-novault > "$(results.chart-template.path)"
        else
          printf no | tee "$(results.standalone-check.path)"
        fi
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
    - image: alpine
      name: library-check
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -x
        if test -d "$(workspaces.source.path)/$(params.CONTEXT)/shared"; then
          printf shared | tee "$(results.shared-check.path)"
        else
          if test -f "$(workspaces.source.path)/$(params.CONTEXT)/pom.xml"; then
            printf . | tee "$(results.shared-check.path)"
          else
            printf no | tee "$(results.shared-check.path)"
          fi
        fi
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
    - image: alpine
      name: nodejs-check
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -x
        if test -f "$(workspaces.source.path)/$(params.CONTEXT)/package.json"; then
          printf . | tee "$(results.nodejs-check.path)" && printf charts/limits-template-nodejs > "$(results.chart-template.path)"
        else
          printf no | tee "$(results.nodejs-check.path)"
        fi
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
    workspaces:
    - description: project code
      name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/pipelines.minVersion":"0.17.0","tekton.dev/tags":"image-build"},"labels":{"app.kubernetes.io/version":"0.2"},"name":"buildah","namespace":"tekton-pipelines"},"spec":{"description":"Buildah task builds source into a container image and then pushes it to a container registry.\nBuildah Task builds source into a container image using Project Atomic's Buildah build tool.It uses Buildah's support for building from Dockerfiles, using its buildah bud command.This command executes the directives in the Dockerfile to assemble a container image, then pushes that image to a container registry.","params":[{"description":"Reference of the image buildah will produce.","name":"IMAGE"},{"default":"quay.io/buildah/stable:v1.17.0","description":"The location of the buildah builder image.","name":"BUILDER_IMAGE"},{"default":"overlay","description":"Set buildah storage driver","name":"STORAGE_DRIVER"},{"default":"./Dockerfile","description":"Path to the Dockerfile to build.","name":"DOCKERFILE"},{"default":".","description":"Path to the directory to use as context.","name":"CONTEXT"},{"default":"false","description":"Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)","name":"TLSVERIFY"},{"default":"oci","description":"The format of the built container, oci or docker","name":"FORMAT"},{"default":"","description":"Extra parameters passed for the build command when building images.","name":"BUILD_EXTRA_ARGS"},{"default":"","description":"Extra parameters passed for the push command when pushing images.","name":"PUSH_EXTRA_ARGS","type":"string"}],"results":[{"description":"Digest of the image just built.","name":"IMAGE_DIGEST"}],"steps":[{"image":"$(params.BUILDER_IMAGE)","name":"build","script":"[[ \"$(workspaces.sslcertdir.bound)\" == \"true\" ]] \u0026\u0026 CERT_DIR_FLAG=\"--cert-dir $(workspaces.sslcertdir.path)\"\nbuildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) bud \\\n  $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \\\n  --tls-verify=$(params.TLSVERIFY) --no-cache \\\n  -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)\n","securityContext":{"privileged":true},"volumeMounts":[{"mountPath":"/var/lib/containers","name":"varlibcontainers"}],"workingDir":"$(workspaces.source.path)/$(params.CONTEXT)"},{"image":"$(params.BUILDER_IMAGE)","name":"push","script":"[[ \"$(workspaces.sslcertdir.bound)\" == \"true\" ]] \u0026\u0026 CERT_DIR_FLAG=\"--cert-dir $(workspaces.sslcertdir.path)\"\nbuildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) push \\\n  $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \\\n  --digestfile $(workspaces.source.path)/image-digest $(params.IMAGE) \\\n  docker://$(params.IMAGE)\n","securityContext":{"privileged":true},"volumeMounts":[{"mountPath":"/var/lib/containers","name":"varlibcontainers"}],"workingDir":"$(workspaces.source.path)"},{"image":"$(params.BUILDER_IMAGE)","name":"digest-to-results","script":"cat $(workspaces.source.path)/image-digest | tee /tekton/results/IMAGE_DIGEST"},{"image":"$(params.BUILDER_IMAGE)","name":"cleanup-local-image","script":"[[ \"$(workspaces.sslcertdir.bound)\" == \"true\" ]] \u0026\u0026 CERT_DIR_FLAG=\"--cert-dir $(workspaces.sslcertdir.path)\"\nbuildah --storage-driver=$(params.STORAGE_DRIVER) rmi --force \\\n  $(params.IMAGE)\n","securityContext":{"privileged":true},"volumeMounts":[{"mountPath":"/var/lib/containers","name":"varlibcontainers"}],"workingDir":"$(workspaces.source.path)"}],"volumes":[{"emptyDir":{},"name":"varlibcontainers"}],"workspaces":[{"name":"source"},{"name":"sslcertdir","optional":true}]}}
      tekton.dev/pipelines.minVersion: 0.17.0
      tekton.dev/tags: image-build
    creationTimestamp: "2021-07-07T13:33:01Z"
    generation: 18
    labels:
      app.kubernetes.io/version: "0.2"
    name: buildah
    namespace: tekton-pipelines
    resourceVersion: "47451461"
    uid: 3bbac6be-2aef-445c-afa6-b984acff36a4
  spec:
    description: |-
      Buildah task builds source into a container image and then pushes it to a container registry.
      Buildah Task builds source into a container image using Project Atomic's Buildah build tool.It uses Buildah's support for building from Dockerfiles, using its buildah bud command.This command executes the directives in the Dockerfile to assemble a container image, then pushes that image to a container registry.
    params:
    - description: Reference of the image buildah will produce.
      name: IMAGE
      type: string
    - default: quay.io/buildah/stable:v1.17.0
      description: The location of the buildah builder image.
      name: BUILDER_IMAGE
      type: string
    - default: overlay
      description: Set buildah storage driver
      name: STORAGE_DRIVER
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: DOCKERFILE
      type: string
    - default: .
      description: Path to the directory to use as context.
      name: CONTEXT
      type: string
    - default: "false"
      description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS
        registry)
      name: TLSVERIFY
      type: string
    - default: oci
      description: The format of the built container, oci or docker
      name: FORMAT
      type: string
    - default: ""
      description: Extra parameters passed for the build command when building images.
      name: BUILD_EXTRA_ARGS
      type: string
    - default: ""
      description: Extra parameters passed for the push command when pushing images.
      name: PUSH_EXTRA_ARGS
      type: string
    results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
    steps:
    - image: $(params.BUILDER_IMAGE)
      name: build
      resources: {}
      script: |
        [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
        buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) bud \
          $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \
          --tls-verify=$(params.TLSVERIFY) --no-cache \
          -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)
      securityContext:
        privileged: true
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibcontainers
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
    - image: $(params.BUILDER_IMAGE)
      name: push
      resources: {}
      script: |
        [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
        buildah ${CERT_DIR_FLAG} --storage-driver=$(params.STORAGE_DRIVER) push \
          $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
          --digestfile $(workspaces.source.path)/image-digest $(params.IMAGE) \
          docker://$(params.IMAGE)
      securityContext:
        privileged: true
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibcontainers
      workingDir: $(workspaces.source.path)
    - image: $(params.BUILDER_IMAGE)
      name: digest-to-results
      resources: {}
      script: cat $(workspaces.source.path)/image-digest | tee /tekton/results/IMAGE_DIGEST
    - image: $(params.BUILDER_IMAGE)
      name: cleanup-local-image
      resources: {}
      script: |
        [[ "$(workspaces.sslcertdir.bound)" == "true" ]] && CERT_DIR_FLAG="--cert-dir $(workspaces.sslcertdir.path)"
        buildah --storage-driver=$(params.STORAGE_DRIVER) rmi --force \
          $(params.IMAGE)
      securityContext:
        privileged: true
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibcontainers
      workingDir: $(workspaces.source.path)
    volumes:
    - emptyDir: {}
      name: varlibcontainers
    workspaces:
    - name: source
    - name: sslcertdir
      optional: true
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"cleanup","namespace":"tekton-pipelines"},"spec":{"params":[{"default":"limits-tmp","name":"PROJ_TMP_NS"},{"default":"nexus.l21d31708530003.local:5000/helm:alpine-slim","name":"HELM_IMAGE"},{"name":"SERVICE_NAME"}],"results":[{"description":"helm push information","name":"helm-push"}],"steps":[{"image":"$(params.HELM_IMAGE)","name":"helm-uninstall","script":"#!/usr/bin/env bash\nset -e\nprintf \"Uninstall Helm Charts from temporary Namespace \\n\"\nhelm -n $(params.PROJ_TMP_NS) uninstall $(params.SERVICE_NAME)\n"},{"image":"alpine","name":"other-steps","script":"#!/usr/bin/env sh\nset -e\nprintf \"TBC !!! \\n\"\n"}],"workspaces":[{"name":"source"}]}}
    creationTimestamp: "2021-08-04T13:25:50Z"
    generation: 5
    name: cleanup
    namespace: tekton-pipelines
    resourceVersion: "47991930"
    uid: d89e6b66-4a24-4579-818d-1311938f4f78
  spec:
    params:
    - default: limits-tmp
      name: PROJ_TMP_NS
      type: string
    - default: nexus.l21d31708530003.local:5000/helm:alpine-slim
      name: HELM_IMAGE
      type: string
    - name: SERVICE_NAME
      type: string
    results:
    - description: helm push information
      name: helm-push
    steps:
    - image: $(params.HELM_IMAGE)
      name: helm-uninstall
      resources: {}
      script: |
        #!/usr/bin/env bash
        set -e
        printf "Uninstall Helm Charts from temporary Namespace \n"
        helm -n $(params.PROJ_TMP_NS) uninstall $(params.SERVICE_NAME)
    - image: alpine
      name: other-steps
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -e
        printf "TBC !!! \n"
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      tekton.dev/displayName: upload coverage report to codecov
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: build,ci
    creationTimestamp: "2021-07-19T09:02:29Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
      hub.tekton.dev/catalog: tekton
    name: codecov
    namespace: tekton-pipelines
    resourceVersion: "33180280"
    uid: a65af96a-7ccf-4b76-bb31-e2fe19688876
  spec:
    description: |-
      This task publishes coverage report to Codecov.io.
      This task will help you publishes the coverage report of your project to https://codecov.io.
    params:
    - default: codecov-token
      description: Name of the secret holding the github-token.
      name: codecov-token-secret
      type: string
    - default: token
      description: Name of the secret key holding the codecov token
      name: codecov-token-secret-key
      type: string
    - default:
      - -Z
      description: Extra arguments to be passed to the codecov script.
      name: args
      type: array
    steps:
    - args:
      - $(params.args)
      env:
      - name: CODECOV_TOKEN
        valueFrom:
          secretKeyRef:
            key: $(params.codecov-token-secret-key)
            name: $(params.codecov-token-secret)
      image: gcr.io/tekton-releases/dogfooding/test-runner@sha256:44aa00796831a4ed5586152058dd96a6d14174b8a4ea9fcae663fb37f72c9454
      name: codecov-run
      resources: {}
      script: |
        #!/usr/bin/env bash
        bash <(wget -O- -o/dev/null https://codecov.io/bash) $@
      workingDir: $(workspaces.source.path)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"docker-build","tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"docker, build-image, push-image, dind"},"labels":{"app.kubernetes.io/version":"0.1"},"name":"docker-build","namespace":"tekton-pipelines"},"spec":{"description":"This task will build and push an image using docker. The task will build an out image out of a Dockerfile. This image will be pushed to an image registry. The image will be built and pushed using a dind sidecar over TCP+TLS.","params":[{"description":"Reference of the image docker will produce.","name":"image"},{"default":"docker.io/library/docker:stable@sha256:18ff92d3d31725b53fa6633d60bed323effb6d5d4588be7b547078d384e0d4bf","description":"The location of the docker builder image.","name":"builder_image"},{"default":"docker:dind","description":"The location of the docker-in-docker image.","name":"dind_image"},{"default":"./Dockerfile","description":"Path to the Dockerfile to build.","name":"dockerfile"},{"default":".","description":"Path to the directory to use as context.","name":"context"},{"default":"","description":"Extra parameters passed for the build command when building images.","name":"build_extra_args"},{"default":"","description":"Extra parameters passed for the push command when pushing images.","name":"push_extra_args"},{"default":"","description":"Allows the user to push to an insecure registry that has been specified","name":"insecure_registry"}],"results":[{"description":"Digest of the image just built.","name":"IMAGE_DIGEST"}],"sidecars":[{"args":["--storage-driver=vfs","--userland-proxy=false","--debug","--insecure-registry=$(params.insecure_registry)"],"env":[{"name":"DOCKER_TLS_CERTDIR","value":"/certs"}],"image":"$(params.dind_image)","name":"server","readinessProbe":{"exec":{"command":["ls","/certs/client/ca.pem"]},"periodSeconds":1},"securityContext":{"privileged":true},"volumeMounts":[{"mountPath":"/certs/client","name":"dind-certs"}]}],"steps":[{"env":[{"name":"DOCKER_HOST","value":"tcp://localhost:2376"},{"name":"DOCKER_TLS_VERIFY","value":"1"},{"name":"DOCKER_CERT_PATH","value":"/certs/client"}],"image":"$(params.builder_image)","name":"docker-build","script":"docker build \\\n  $(params.build_extra_args) \\\n  --no-cache \\\n  -f $(params.dockerfile) -t $(params.image) $(params.context)\n","volumeMounts":[{"mountPath":"/certs/client","name":"dind-certs"}],"workingDir":"$(workspaces.source.path)"},{"env":[{"name":"DOCKER_HOST","value":"tcp://localhost:2376"},{"name":"DOCKER_TLS_VERIFY","value":"1"},{"name":"DOCKER_CERT_PATH","value":"/certs/client"}],"image":"$(params.builder_image)","name":"docker-push","script":"docker push $(params.push_extra_args) $(params.image)\n","volumeMounts":[{"mountPath":"/certs/client","name":"dind-certs"}],"workingDir":"$(workspaces.source.path)"}],"volumes":[{"emptyDir":{},"name":"dind-certs"}],"workspaces":[{"name":"source"}]}}
      tekton.dev/displayName: docker-build
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: docker, build-image, push-image, dind
    creationTimestamp: "2021-07-10T12:50:41Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
    name: docker-build
    namespace: tekton-pipelines
    resourceVersion: "25870528"
    uid: f9d18d02-368d-4a7d-9b16-201fcd462dec
  spec:
    description: This task will build and push an image using docker. The task will
      build an out image out of a Dockerfile. This image will be pushed to an image
      registry. The image will be built and pushed using a dind sidecar over TCP+TLS.
    params:
    - description: Reference of the image docker will produce.
      name: image
      type: string
    - default: docker.io/library/docker:stable@sha256:18ff92d3d31725b53fa6633d60bed323effb6d5d4588be7b547078d384e0d4bf
      description: The location of the docker builder image.
      name: builder_image
      type: string
    - default: docker:dind
      description: The location of the docker-in-docker image.
      name: dind_image
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: dockerfile
      type: string
    - default: .
      description: Path to the directory to use as context.
      name: context
      type: string
    - default: ""
      description: Extra parameters passed for the build command when building images.
      name: build_extra_args
      type: string
    - default: ""
      description: Extra parameters passed for the push command when pushing images.
      name: push_extra_args
      type: string
    - default: ""
      description: Allows the user to push to an insecure registry that has been specified
      name: insecure_registry
      type: string
    results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
    sidecars:
    - Workspaces: null
      args:
      - --storage-driver=vfs
      - --userland-proxy=false
      - --debug
      - --insecure-registry=$(params.insecure_registry)
      env:
      - name: DOCKER_TLS_CERTDIR
        value: /certs
      image: $(params.dind_image)
      name: server
      readinessProbe:
        exec:
          command:
          - ls
          - /certs/client/ca.pem
        periodSeconds: 1
      resources: {}
      securityContext:
        privileged: true
      volumeMounts:
      - mountPath: /certs/client
        name: dind-certs
    steps:
    - env:
      - name: DOCKER_HOST
        value: tcp://localhost:2376
      - name: DOCKER_TLS_VERIFY
        value: "1"
      - name: DOCKER_CERT_PATH
        value: /certs/client
      image: $(params.builder_image)
      name: docker-build
      resources: {}
      script: |
        docker build \
          $(params.build_extra_args) \
          --no-cache \
          -f $(params.dockerfile) -t $(params.image) $(params.context)
      volumeMounts:
      - mountPath: /certs/client
        name: dind-certs
      workingDir: $(workspaces.source.path)
    - env:
      - name: DOCKER_HOST
        value: tcp://localhost:2376
      - name: DOCKER_TLS_VERIFY
        value: "1"
      - name: DOCKER_CERT_PATH
        value: /certs/client
      image: $(params.builder_image)
      name: docker-push
      resources: {}
      script: |
        docker push $(params.push_extra_args) $(params.image)
      volumeMounts:
      - mountPath: /certs/client
        name: dind-certs
      workingDir: $(workspaces.source.path)
    volumes:
    - emptyDir: {}
      name: dind-certs
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"buildid","tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"build-tool"},"labels":{"app.kubernetes.io/version":"0.1"},"name":"generate-build-id","namespace":"tekton-pipelines"},"spec":{"description":"Extract artifact version from springboot apps or nodejs and provide information as results for other tasks that are creating next level of artifacts like docker images or helm charts.","params":[{"default":".","name":"CONTEXT_DIR"}],"results":[{"description":"Current timestamp","name":"timestamp"},{"description":"ID of the current build","name":"build-id"}],"steps":[{"image":"docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d","name":"get-timestamp","script":"#!/usr/bin/env bash\nts=`date \"+%Y%m%d%H%M%S\"`\necho \"Current Timestamp: ${ts}\"\necho ${ts} | tr -d \"\\n\" | tee $(results.timestamp.path)\necho \"Current PipelineRun: $(context.pipelineRun.uid)\"\n"},{"image":"bitnami/minideb","name":"get-buildid","script":"#!/usr/bin/env bash\nts=`cat $(results.timestamp.path)`\nif [ -f pom.xml ]; then\n  buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?\u003c=\u003cversion\u003e).*(?=\\-SNAPSHOT\u003c/version\u003e)')-${ts}\nelse\n  buildId=$(cat package.json |grep version|tr -d version\\\"\\,\\:|xargs)-${ts}\nfi\necho $(context.pipelineRun.uid)\necho ${buildId} | tr -d \"\\n\" | tee $(results.build-id.path)\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"name":"source"}]}}
      tekton.dev/displayName: buildid
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: build-tool
    creationTimestamp: "2021-07-10T11:52:47Z"
    generation: 4
    labels:
      app.kubernetes.io/version: "0.1"
    name: generate-build-id
    namespace: tekton-pipelines
    resourceVersion: "39131861"
    uid: 4b1f8d8f-7143-4c64-956e-f02d8731851a
  spec:
    description: Extract artifact version from springboot apps or nodejs and provide
      information as results for other tasks that are creating next level of artifacts
      like docker images or helm charts.
    params:
    - default: .
      name: CONTEXT_DIR
      type: string
    results:
    - description: Current timestamp
      name: timestamp
    - description: ID of the current build
      name: build-id
    steps:
    - image: docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d
      name: get-timestamp
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`date "+%Y%m%d%H%M%S"`
        echo "Current Timestamp: ${ts}"
        echo ${ts} | tr -d "\n" | tee $(results.timestamp.path)
        echo "Current PipelineRun: $(context.pipelineRun.uid)"
    - image: bitnami/minideb
      name: get-buildid
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`cat $(results.timestamp.path)`
        if [ -f pom.xml ]; then
          buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?<=<version>).*(?=\-SNAPSHOT</version>)')-${ts}
        else
          buildId=$(cat package.json |grep version|tr -d version\"\,\:|xargs)-${ts}
        fi
        echo $(context.pipelineRun.uid)
        echo ${buildId} | tr -d "\n" | tee $(results.build-id.path)
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"buildid","tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"build-tool"},"labels":{"app.kubernetes.io/version":"0.1"},"name":"generate-build-id-check","namespace":"tekton-pipelines"},"spec":{"description":"Given a base version, this task generates a unique build id by appending the base-version to the current timestamp.","params":[{"default":".","name":"CONTEXT_DIR"}],"results":[{"description":"Current timestamp","name":"timestamp"},{"description":"ID of the current build","name":"build-id"}],"steps":[{"image":"docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d","name":"get-timestamp","script":"#!/usr/bin/env bash\nts=`date \"+%Y%m%d%H%M%S\"`\necho \"Current Timestamp: ${ts}\"\necho ${ts} | tr -d \"\\n\" | tee $(results.timestamp.path)\n"},{"image":"bitnami/minideb","name":"get-buildid","script":"#!/usr/bin/env bash\nts=`cat $(results.timestamp.path)`\nif [ -f pom.xml ]; then\n  buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?\u003c=\u003cversion\u003e).*(?=\\-SNAPSHOT\u003c/version\u003e)')-${ts}\nelse\n  buildId=$(cat package.json |grep version|tr -d version\\\"\\,\\:|xargs)-${ts}\nfi\necho ${buildId} | tr -d \"\\n\" | tee $(results.build-id.path)\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"name":"source"}]}}
      tekton.dev/displayName: buildid
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: build-tool
    creationTimestamp: "2021-07-21T17:29:19Z"
    generation: 2
    labels:
      app.kubernetes.io/version: "0.1"
    name: generate-build-id-check
    namespace: tekton-pipelines
    resourceVersion: "35122554"
    uid: 0e302ac9-b64c-4e8c-9b37-548b017ee4dd
  spec:
    description: Given a base version, this task generates a unique build id by appending
      the base-version to the current timestamp.
    params:
    - default: .
      name: CONTEXT_DIR
      type: string
    results:
    - description: Current timestamp
      name: timestamp
    - description: ID of the current build
      name: build-id
    steps:
    - image: docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d
      name: get-timestamp
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`date "+%Y%m%d%H%M%S"`
        echo "Current Timestamp: ${ts}"
        echo ${ts} | tr -d "\n" | tee $(results.timestamp.path)
    - image: bitnami/minideb
      name: get-buildid
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`cat $(results.timestamp.path)`
        if [ -f pom.xml ]; then
          buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?<=<version>).*(?=\-SNAPSHOT</version>)')-${ts}
        else
          buildId=$(cat package.json |grep version|tr -d version\"\,\:|xargs)-${ts}
        fi
        echo ${buildId} | tr -d "\n" | tee $(results.build-id.path)
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"buildid","tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"build-tool"},"labels":{"app.kubernetes.io/version":"0.1"},"name":"generate-build-id-copy","namespace":"tekton-pipelines"},"spec":{"description":"Given a base version, this task generates a unique build id by appending the base-version to the current timestamp.","params":[{"default":".","name":"CONTEXT_DIR"}],"results":[{"description":"Current timestamp","name":"timestamp"},{"description":"ID of the current build","name":"build-id"}],"steps":[{"image":"docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d","name":"get-timestamp","script":"#!/usr/bin/env bash\nts=`date \"+%Y%m%d%H%M%S\"`\necho \"Current Timestamp: ${ts}\"\necho ${ts} | tr -d \"\\n\" | tee $(results.timestamp.path)\n"},{"image":"bitnami/minideb","name":"get-buildid","script":"#!/usr/bin/env bash\nts=`cat $(results.timestamp.path)`\nbuildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?\u003c=\u003cversion\u003e).*(?=\\-SNAPSHOT\u003c/version\u003e)')-${ts}\necho ${buildId} | tr -d \"\\n\" | tee $(results.build-id.path)\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"name":"source"}]}}
      tekton.dev/displayName: buildid
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: build-tool
    creationTimestamp: "2021-07-10T12:30:45Z"
    generation: 7
    labels:
      app.kubernetes.io/version: "0.1"
    name: generate-build-id-copy
    namespace: tekton-pipelines
    resourceVersion: "26671056"
    uid: 0d101759-8ee7-47e4-81ec-a29fafb2a8dd
  spec:
    description: Given a base version, this task generates a unique build id by appending
      the base-version to the current timestamp.
    params:
    - default: .
      name: CONTEXT_DIR
      type: string
    results:
    - description: Current timestamp
      name: timestamp
    - description: ID of the current build
      name: build-id
    steps:
    - image: docker.io/library/bash:5.0.18@sha256:8ef3f8518f47caf1ddcbdf49e983a9a119f9faeb41c2468dd20ff39cd242d69d
      name: get-timestamp
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`date "+%Y%m%d%H%M%S"`
        echo "Current Timestamp: ${ts}"
        echo ${ts} | tr -d "\n" | tee $(results.timestamp.path)
    - image: bitnami/minideb
      name: get-buildid
      resources: {}
      script: |
        #!/usr/bin/env bash
        ts=`cat $(results.timestamp.path)`
        buildId=$(grep -A2 com.finastr pom.xml |grep -o -P '(?<=<version>).*(?=\-SNAPSHOT</version>)')-${ts}
        echo ${buildId} | tr -d "\n" | tee $(results.build-id.path)
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      tekton.dev/displayName: git cli
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: git
    creationTimestamp: "2021-07-06T16:58:01Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
    name: git-cli
    namespace: tekton-pipelines
    resourceVersion: "22750899"
    uid: 44692be3-dcee-438b-957f-4d7c406b2834
  spec:
    description: |-
      This task can be used to perform git operations.
      Git command that needs to be run can be passed as a script to the task.This task needs authentication to git in order to push after the git operation.
    params:
    - default: docker.io/alpine/git:v2.26.2@sha256:23618034b0be9205d9cc0846eb711b12ba4c9b468efdd8a59aac1d7b1a23363f
      description: |
        The base image for the task.
      name: BASE_IMAGE
      type: string
    - default: ""
      description: |
        Git user name for performing git operation.
      name: GIT_USER_NAME
      type: string
    - default: ""
      description: |
        Git user email for performing git operation.
      name: GIT_USER_EMAIL
      type: string
    - default: |
        git help
      description: The git script to run.
      name: GIT_SCRIPT
      type: string
    results:
    - description: The precise commit SHA after the git operation.
      name: commit
    steps:
    - image: $(params.BASE_IMAGE)
      name: git
      resources: {}
      script: |2

        # Setting up the config for the git.
        git config --global user.email "$(params.GIT_USER_EMAIL)"
        git config --global user.name "$(params.GIT_USER_NAME)"

        $(params.GIT_SCRIPT)

        RESULT_SHA="$(git rev-parse HEAD | tr -d '\n')"
        EXIT_CODE="$?"
        if [ "$EXIT_CODE" != 0 ]
        then
          exit $EXIT_CODE
        fi
        # Make sure we don't add a trailing newline to the result!
        echo -n "$RESULT_SHA" > $(results.commit.path)
      workingDir: $(workspaces.source.path)
    workspaces:
    - description: A workspace that contains the fetched git repository.
      name: source
    - description: A workspace that contains file that needs to be added to git.
      name: input
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"git clone","tekton.dev/pipelines.minVersion":"0.21.0","tekton.dev/tags":"git"},"labels":{"app.kubernetes.io/version":"0.4"},"name":"git-clone","namespace":"tekton-pipelines"},"spec":{"description":"These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline.\nThe git-clone Task will clone a repo from the provided url into the source Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.","params":[{"description":"Repository URL to clone from.","name":"url","type":"string"},{"default":"","description":"Revision to checkout. (branch, tag, sha, ref, etc...)","name":"revision","type":"string"},{"default":"","description":"Refspec to fetch before checking out revision.","name":"refspec"},{"default":"true","description":"Initialize and fetch git submodules.","name":"submodules","type":"string"},{"default":"1","description":"Perform a shallow clone, fetching only the most recent N commits.","name":"depth","type":"string"},{"default":"true","description":"Set the `http.sslVerify` global git config. Setting this to `false` is not advised unless you are sure that you trust your git remote.","name":"sslVerify","type":"string"},{"default":"","description":"Subdirectory inside the `source` Workspace to clone the repo into.","name":"subdirectory","type":"string"},{"default":"","description":"Define the directory patterns to match or exclude when performing a sparse checkout.","name":"sparseCheckoutDirectories","type":"string"},{"default":"true","description":"Clean out the contents of the destination directory if it already exists before cloning.","name":"deleteExisting","type":"string"},{"default":"","description":"HTTP proxy server for non-SSL requests.","name":"httpProxy","type":"string"},{"default":"","description":"HTTPS proxy server for SSL requests.","name":"httpsProxy","type":"string"},{"default":"","description":"Opt out of proxying HTTP/HTTPS requests.","name":"noProxy","type":"string"},{"default":"true","description":"Log the commands that are executed during `git-clone`'s operation.","name":"verbose","type":"string"},{"default":"gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0","description":"The image providing the git-init binary that this Task runs.","name":"gitInitImage","type":"string"},{"default":"/root","description":"Absolute path to the user's home directory. Set this explicitly if you are running the image as a non-root user or have overridden\nthe gitInitImage param with an image containing custom user configuration.\n","name":"userHome","type":"string"}],"results":[{"description":"The precise commit SHA that was fetched by this Task.","name":"commit"},{"description":"The precise URL that was fetched by this Task.","name":"url"}],"steps":[{"env":[{"name":"HOME","value":"$(params.userHome)"},{"name":"PARAM_URL","value":"$(params.url)"},{"name":"PARAM_REVISION","value":"$(params.revision)"},{"name":"PARAM_REFSPEC","value":"$(params.refspec)"},{"name":"PARAM_SUBMODULES","value":"$(params.submodules)"},{"name":"PARAM_DEPTH","value":"$(params.depth)"},{"name":"PARAM_SSL_VERIFY","value":"$(params.sslVerify)"},{"name":"PARAM_SUBDIRECTORY","value":"$(params.subdirectory)"},{"name":"PARAM_DELETE_EXISTING","value":"$(params.deleteExisting)"},{"name":"PARAM_HTTP_PROXY","value":"$(params.httpProxy)"},{"name":"PARAM_HTTPS_PROXY","value":"$(params.httpsProxy)"},{"name":"PARAM_NO_PROXY","value":"$(params.noProxy)"},{"name":"PARAM_VERBOSE","value":"$(params.verbose)"},{"name":"PARAM_SPARSE_CHECKOUT_DIRECTORIES","value":"$(params.sparseCheckoutDirectories)"},{"name":"PARAM_USER_HOME","value":"$(params.userHome)"},{"name":"WORKSPACE_SOURCE_PATH","value":"$(workspaces.source.path)"},{"name":"WORKSPACE_SSH_DIRECTORY_BOUND","value":"$(workspaces.ssh-directory.bound)"},{"name":"WORKSPACE_SSH_DIRECTORY_PATH","value":"$(workspaces.ssh-directory.path)"},{"name":"WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND","value":"$(workspaces.basic-auth.bound)"},{"name":"WORKSPACE_BASIC_AUTH_DIRECTORY_PATH","value":"$(workspaces.basic-auth.path)"}],"image":"$(params.gitInitImage)","name":"clone","script":"#!/usr/bin/env sh\nset -eu\n\nif [ \"${PARAM_VERBOSE}\" = \"true\" ] ; then\n  set -x\nfi\n\nif [ \"${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}\" = \"true\" ] ; then\n  cp \"${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials\" \"${PARAM_USER_HOME}/.git-credentials\"\n  cp \"${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig\" \"${PARAM_USER_HOME}/.gitconfig\"\n  chmod 400 \"${PARAM_USER_HOME}/.git-credentials\"\n  chmod 400 \"${PARAM_USER_HOME}/.gitconfig\"\nfi\n\nif [ \"${WORKSPACE_SSH_DIRECTORY_BOUND}\" = \"true\" ] ; then\n  cp -R \"${WORKSPACE_SSH_DIRECTORY_PATH}\" \"${PARAM_USER_HOME}\"/.ssh\n  chmod 700 \"${PARAM_USER_HOME}\"/.ssh\n  chmod -R 400 \"${PARAM_USER_HOME}\"/.ssh/*\nfi\n\nCHECKOUT_DIR=\"${WORKSPACE_SOURCE_PATH}/${PARAM_SUBDIRECTORY}\"\n\ncleandir() {\n  # Delete any existing contents of the repo directory if it exists.\n  #\n  # We don't just \"rm -rf ${CHECKOUT_DIR}\" because ${CHECKOUT_DIR} might be \"/\"\n  # or the root of a mounted volume.\n  if [ -d \"${CHECKOUT_DIR}\" ] ; then\n    # Delete non-hidden files and directories\n    rm -rf \"${CHECKOUT_DIR:?}\"/*\n    # Delete files and directories starting with . but excluding ..\n    rm -rf \"${CHECKOUT_DIR}\"/.[!.]*\n    # Delete files and directories starting with .. plus any other character\n    rm -rf \"${CHECKOUT_DIR}\"/..?*\n  fi\n}\n\nif [ \"${PARAM_DELETE_EXISTING}\" = \"true\" ] ; then\n  cleandir\nfi\n\ntest -z \"${PARAM_HTTP_PROXY}\" || export HTTP_PROXY=\"${PARAM_HTTP_PROXY}\"\ntest -z \"${PARAM_HTTPS_PROXY}\" || export HTTPS_PROXY=\"${PARAM_HTTPS_PROXY}\"\ntest -z \"${PARAM_NO_PROXY}\" || export NO_PROXY=\"${PARAM_NO_PROXY}\"\n\n/ko-app/git-init \\\n  -url=\"${PARAM_URL}\" \\\n  -revision=\"${PARAM_REVISION}\" \\\n  -refspec=\"${PARAM_REFSPEC}\" \\\n  -path=\"${CHECKOUT_DIR}\" \\\n  -sslVerify=\"${PARAM_SSL_VERIFY}\" \\\n  -submodules=\"${PARAM_SUBMODULES}\" \\\n  -depth=\"${PARAM_DEPTH}\" \\\n  -sparseCheckoutDirectories=\"${PARAM_SPARSE_CHECKOUT_DIRECTORIES}\"\ncd \"${CHECKOUT_DIR}\"\nRESULT_SHA=\"$(git rev-parse HEAD)\"\nEXIT_CODE=\"$?\"\nif [ \"${EXIT_CODE}\" != 0 ] ; then\n  exit \"${EXIT_CODE}\"\nfi\nprintf \"%s\" \"${RESULT_SHA}\" \u003e \"$(results.commit.path)\"\nprintf \"%s\" \"${PARAM_URL}\" \u003e \"$(results.url.path)\"\n"}],"workspaces":[{"description":"The git repo will be cloned onto the volume backing this Workspace.","name":"source"},{"description":"A .ssh directory with private key, known_hosts, config, etc. Copied to\nthe user's home before git commands are executed. Used to authenticate\nwith the git remote when performing the clone. Binding a Secret to this\nWorkspace is strongly recommended over other volume types.\n","name":"ssh-directory","optional":true},{"description":"A Workspace containing a .gitconfig and .git-credentials file. These\nwill be copied to the user's home before any git commands are run. Any\nother files in this Workspace are ignored. It is strongly recommended\nto use ssh-directory over basic-auth whenever possible and to bind a\nSecret to this Workspace over other volume types.\n","name":"basic-auth","optional":true}]}}
      tekton.dev/displayName: git clone
      tekton.dev/pipelines.minVersion: 0.21.0
      tekton.dev/tags: git
    creationTimestamp: "2021-07-06T16:58:11Z"
    generation: 2
    labels:
      app.kubernetes.io/version: "0.4"
    name: git-clone
    namespace: tekton-pipelines
    resourceVersion: "27425235"
    uid: 19b42d6a-dd22-45f1-b001-6b8fe88dfab8
  spec:
    description: |-
      These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline.
      The git-clone Task will clone a repo from the provided url into the source Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.
    params:
    - description: Repository URL to clone from.
      name: url
      type: string
    - default: ""
      description: Revision to checkout. (branch, tag, sha, ref, etc...)
      name: revision
      type: string
    - default: ""
      description: Refspec to fetch before checking out revision.
      name: refspec
      type: string
    - default: "true"
      description: Initialize and fetch git submodules.
      name: submodules
      type: string
    - default: "1"
      description: Perform a shallow clone, fetching only the most recent N commits.
      name: depth
      type: string
    - default: "true"
      description: Set the `http.sslVerify` global git config. Setting this to `false`
        is not advised unless you are sure that you trust your git remote.
      name: sslVerify
      type: string
    - default: ""
      description: Subdirectory inside the `source` Workspace to clone the repo into.
      name: subdirectory
      type: string
    - default: ""
      description: Define the directory patterns to match or exclude when performing
        a sparse checkout.
      name: sparseCheckoutDirectories
      type: string
    - default: "true"
      description: Clean out the contents of the destination directory if it already
        exists before cloning.
      name: deleteExisting
      type: string
    - default: ""
      description: HTTP proxy server for non-SSL requests.
      name: httpProxy
      type: string
    - default: ""
      description: HTTPS proxy server for SSL requests.
      name: httpsProxy
      type: string
    - default: ""
      description: Opt out of proxying HTTP/HTTPS requests.
      name: noProxy
      type: string
    - default: "true"
      description: Log the commands that are executed during `git-clone`'s operation.
      name: verbose
      type: string
    - default: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0
      description: The image providing the git-init binary that this Task runs.
      name: gitInitImage
      type: string
    - default: /root
      description: |
        Absolute path to the user's home directory. Set this explicitly if you are running the image as a non-root user or have overridden
        the gitInitImage param with an image containing custom user configuration.
      name: userHome
      type: string
    results:
    - description: The precise commit SHA that was fetched by this Task.
      name: commit
    - description: The precise URL that was fetched by this Task.
      name: url
    steps:
    - env:
      - name: HOME
        value: $(params.userHome)
      - name: PARAM_URL
        value: $(params.url)
      - name: PARAM_REVISION
        value: $(params.revision)
      - name: PARAM_REFSPEC
        value: $(params.refspec)
      - name: PARAM_SUBMODULES
        value: $(params.submodules)
      - name: PARAM_DEPTH
        value: $(params.depth)
      - name: PARAM_SSL_VERIFY
        value: $(params.sslVerify)
      - name: PARAM_SUBDIRECTORY
        value: $(params.subdirectory)
      - name: PARAM_DELETE_EXISTING
        value: $(params.deleteExisting)
      - name: PARAM_HTTP_PROXY
        value: $(params.httpProxy)
      - name: PARAM_HTTPS_PROXY
        value: $(params.httpsProxy)
      - name: PARAM_NO_PROXY
        value: $(params.noProxy)
      - name: PARAM_VERBOSE
        value: $(params.verbose)
      - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
        value: $(params.sparseCheckoutDirectories)
      - name: PARAM_USER_HOME
        value: $(params.userHome)
      - name: WORKSPACE_SOURCE_PATH
        value: $(workspaces.source.path)
      - name: WORKSPACE_SSH_DIRECTORY_BOUND
        value: $(workspaces.ssh-directory.bound)
      - name: WORKSPACE_SSH_DIRECTORY_PATH
        value: $(workspaces.ssh-directory.path)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
        value: $(workspaces.basic-auth.bound)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
        value: $(workspaces.basic-auth.path)
      image: $(params.gitInitImage)
      name: clone
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -eu

        if [ "${PARAM_VERBOSE}" = "true" ] ; then
          set -x
        fi

        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ] ; then
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials" "${PARAM_USER_HOME}/.git-credentials"
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig" "${PARAM_USER_HOME}/.gitconfig"
          chmod 400 "${PARAM_USER_HOME}/.git-credentials"
          chmod 400 "${PARAM_USER_HOME}/.gitconfig"
        fi

        if [ "${WORKSPACE_SSH_DIRECTORY_BOUND}" = "true" ] ; then
          cp -R "${WORKSPACE_SSH_DIRECTORY_PATH}" "${PARAM_USER_HOME}"/.ssh
          chmod 700 "${PARAM_USER_HOME}"/.ssh
          chmod -R 400 "${PARAM_USER_HOME}"/.ssh/*
        fi

        CHECKOUT_DIR="${WORKSPACE_SOURCE_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf ${CHECKOUT_DIR}" because ${CHECKOUT_DIR} might be "/"
          # or the root of a mounted volume.
          if [ -d "${CHECKOUT_DIR}" ] ; then
            # Delete non-hidden files and directories
            rm -rf "${CHECKOUT_DIR:?}"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "${CHECKOUT_DIR}"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "${CHECKOUT_DIR}"/..?*
          fi
        }

        if [ "${PARAM_DELETE_EXISTING}" = "true" ] ; then
          cleandir
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        /ko-app/git-init \
          -url="${PARAM_URL}" \
          -revision="${PARAM_REVISION}" \
          -refspec="${PARAM_REFSPEC}" \
          -path="${CHECKOUT_DIR}" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth="${PARAM_DEPTH}" \
          -sparseCheckoutDirectories="${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "${CHECKOUT_DIR}"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "${EXIT_CODE}" != 0 ] ; then
          exit "${EXIT_CODE}"
        fi
        printf "%s" "${RESULT_SHA}" > "$(results.commit.path)"
        printf "%s" "${PARAM_URL}" > "$(results.url.path)"
    workspaces:
    - description: The git repo will be cloned onto the volume backing this Workspace.
      name: source
    - description: |
        A .ssh directory with private key, known_hosts, config, etc. Copied to
        the user's home before git commands are executed. Used to authenticate
        with the git remote when performing the clone. Binding a Secret to this
        Workspace is strongly recommended over other volume types.
      name: ssh-directory
      optional: true
    - description: |
        A Workspace containing a .gitconfig and .git-credentials file. These
        will be copied to the user's home before any git commands are run. Any
        other files in this Workspace are ignored. It is strongly recommended
        to use ssh-directory over basic-auth whenever possible and to bind a
        Secret to this Workspace over other volume types.
      name: basic-auth
      optional: true
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"git clone","tekton.dev/pipelines.minVersion":"0.21.0","tekton.dev/tags":"git"},"labels":{"app.kubernetes.io/version":"0.4"},"name":"git-clone-copy","namespace":"tekton-pipelines"},"spec":{"description":"These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline.\nThe git-clone Task will clone a repo from the provided url into the source Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.","params":[{"default":"","description":"Revision to checkout. (branch, tag, sha, ref, etc...)","name":"revision","type":"string"},{"default":"","description":"Refspec to fetch before checking out revision.","name":"refspec"},{"default":"true","description":"Initialize and fetch git submodules.","name":"submodules","type":"string"},{"default":"1","description":"Perform a shallow clone, fetching only the most recent N commits.","name":"depth","type":"string"},{"default":"true","description":"Set the `http.sslVerify` global git config. Setting this to `false` is not advised unless you are sure that you trust your git remote.","name":"sslVerify","type":"string"},{"default":"","description":"Subdirectory inside the `source` Workspace to clone the repo into.","name":"subdirectory","type":"string"},{"default":"","description":"Define the directory patterns to match or exclude when performing a sparse checkout.","name":"sparseCheckoutDirectories","type":"string"},{"default":"true","description":"Clean out the contents of the destination directory if it already exists before cloning.","name":"deleteExisting","type":"string"},{"default":"","description":"HTTP proxy server for non-SSL requests.","name":"httpProxy","type":"string"},{"default":"","description":"HTTPS proxy server for SSL requests.","name":"httpsProxy","type":"string"},{"default":"","description":"Opt out of proxying HTTP/HTTPS requests.","name":"noProxy","type":"string"},{"default":"true","description":"Log the commands that are executed during `git-clone`'s operation.","name":"verbose","type":"string"},{"default":"gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0","description":"The image providing the git-init binary that this Task runs.","name":"gitInitImage","type":"string"},{"default":"/root","description":"Absolute path to the user's home directory. Set this explicitly if you are running the image as a non-root user or have overridden\nthe gitInitImage param with an image containing custom user configuration.\n","name":"userHome","type":"string"}],"resources":{"inputs":[{"name":"git-source","optional":true,"type":"git"}]},"results":[{"description":"The precise commit SHA that was fetched by this Task.","name":"commit"},{"description":"The precise URL that was fetched by this Task.","name":"url"}],"steps":[{"env":[{"name":"HOME","value":"$(params.userHome)"},{"name":"PARAM_URL","value":"$(resources.inputs.git-source.url)"},{"name":"PARAM_REVISION","value":"$(params.revision)"},{"name":"PARAM_REFSPEC","value":"$(params.refspec)"},{"name":"PARAM_SUBMODULES","value":"$(params.submodules)"},{"name":"PARAM_DEPTH","value":"$(params.depth)"},{"name":"PARAM_SSL_VERIFY","value":"$(params.sslVerify)"},{"name":"PARAM_SUBDIRECTORY","value":"$(params.subdirectory)"},{"name":"PARAM_DELETE_EXISTING","value":"$(params.deleteExisting)"},{"name":"PARAM_HTTP_PROXY","value":"$(params.httpProxy)"},{"name":"PARAM_HTTPS_PROXY","value":"$(params.httpsProxy)"},{"name":"PARAM_NO_PROXY","value":"$(params.noProxy)"},{"name":"PARAM_VERBOSE","value":"$(params.verbose)"},{"name":"PARAM_SPARSE_CHECKOUT_DIRECTORIES","value":"$(params.sparseCheckoutDirectories)"},{"name":"PARAM_USER_HOME","value":"$(params.userHome)"},{"name":"WORKSPACE_SOURCE_PATH","value":"$(workspaces.source.path)"},{"name":"WORKSPACE_SSH_DIRECTORY_BOUND","value":"$(workspaces.ssh-directory.bound)"},{"name":"WORKSPACE_SSH_DIRECTORY_PATH","value":"$(workspaces.ssh-directory.path)"},{"name":"WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND","value":"$(workspaces.basic-auth.bound)"},{"name":"WORKSPACE_BASIC_AUTH_DIRECTORY_PATH","value":"$(workspaces.basic-auth.path)"}],"image":"$(params.gitInitImage)","name":"clone","script":"#!/usr/bin/env sh\nset -eu\n\nif [ \"${PARAM_VERBOSE}\" = \"true\" ] ; then\n  set -x\nfi\n\nif [ \"${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}\" = \"true\" ] ; then\n  cp \"${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials\" \"${PARAM_USER_HOME}/.git-credentials\"\n  cp \"${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig\" \"${PARAM_USER_HOME}/.gitconfig\"\n  chmod 400 \"${PARAM_USER_HOME}/.git-credentials\"\n  chmod 400 \"${PARAM_USER_HOME}/.gitconfig\"\nfi\n\nif [ \"${WORKSPACE_SSH_DIRECTORY_BOUND}\" = \"true\" ] ; then\n  cp -R \"${WORKSPACE_SSH_DIRECTORY_PATH}\" \"${PARAM_USER_HOME}\"/.ssh\n  chmod 700 \"${PARAM_USER_HOME}\"/.ssh\n  chmod -R 400 \"${PARAM_USER_HOME}\"/.ssh/*\nfi\n\nCHECKOUT_DIR=\"${WORKSPACE_SOURCE_PATH}/${PARAM_SUBDIRECTORY}\"\n\ncleandir() {\n  # Delete any existing contents of the repo directory if it exists.\n  #\n  # We don't just \"rm -rf ${CHECKOUT_DIR}\" because ${CHECKOUT_DIR} might be \"/\"\n  # or the root of a mounted volume.\n  if [ -d \"${CHECKOUT_DIR}\" ] ; then\n    # Delete non-hidden files and directories\n    rm -rf \"${CHECKOUT_DIR:?}\"/*\n    # Delete files and directories starting with . but excluding ..\n    rm -rf \"${CHECKOUT_DIR}\"/.[!.]*\n    # Delete files and directories starting with .. plus any other character\n    rm -rf \"${CHECKOUT_DIR}\"/..?*\n  fi\n}\n\nif [ \"${PARAM_DELETE_EXISTING}\" = \"true\" ] ; then\n  cleandir\nfi\n\ntest -z \"${PARAM_HTTP_PROXY}\" || export HTTP_PROXY=\"${PARAM_HTTP_PROXY}\"\ntest -z \"${PARAM_HTTPS_PROXY}\" || export HTTPS_PROXY=\"${PARAM_HTTPS_PROXY}\"\ntest -z \"${PARAM_NO_PROXY}\" || export NO_PROXY=\"${PARAM_NO_PROXY}\"\n\n/ko-app/git-init \\\n  -url=\"${PARAM_URL}\" \\\n  -revision=\"${PARAM_REVISION}\" \\\n  -refspec=\"${PARAM_REFSPEC}\" \\\n  -path=\"${CHECKOUT_DIR}\" \\\n  -sslVerify=\"${PARAM_SSL_VERIFY}\" \\\n  -submodules=\"${PARAM_SUBMODULES}\" \\\n  -depth=\"${PARAM_DEPTH}\" \\\n  -sparseCheckoutDirectories=\"${PARAM_SPARSE_CHECKOUT_DIRECTORIES}\"\ncd \"${CHECKOUT_DIR}\"\nRESULT_SHA=\"$(git rev-parse HEAD)\"\nEXIT_CODE=\"$?\"\nif [ \"${EXIT_CODE}\" != 0 ] ; then\n  exit \"${EXIT_CODE}\"\nfi\nprintf \"%s\" \"${RESULT_SHA}\" \u003e \"$(results.commit.path)\"\nprintf \"%s\" \"${PARAM_URL}\" \u003e \"$(results.url.path)\"\n"}],"workspaces":[{"description":"The git repo will be cloned onto the volume backing this Workspace.","name":"source"}]}}
      tekton.dev/displayName: git clone
      tekton.dev/pipelines.minVersion: 0.21.0
      tekton.dev/tags: git
    creationTimestamp: "2021-07-08T13:33:51Z"
    generation: 18
    labels:
      app.kubernetes.io/version: "0.4"
    name: git-clone-copy
    namespace: tekton-pipelines
    resourceVersion: "25931948"
    uid: 093ea835-672b-4f20-8f0a-ef1fe7825fc0
  spec:
    description: |-
      These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline.
      The git-clone Task will clone a repo from the provided url into the source Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.
    params:
    - default: ""
      description: Revision to checkout. (branch, tag, sha, ref, etc...)
      name: revision
      type: string
    - default: ""
      description: Refspec to fetch before checking out revision.
      name: refspec
      type: string
    - default: "true"
      description: Initialize and fetch git submodules.
      name: submodules
      type: string
    - default: "1"
      description: Perform a shallow clone, fetching only the most recent N commits.
      name: depth
      type: string
    - default: "true"
      description: Set the `http.sslVerify` global git config. Setting this to `false`
        is not advised unless you are sure that you trust your git remote.
      name: sslVerify
      type: string
    - default: ""
      description: Subdirectory inside the `source` Workspace to clone the repo into.
      name: subdirectory
      type: string
    - default: ""
      description: Define the directory patterns to match or exclude when performing
        a sparse checkout.
      name: sparseCheckoutDirectories
      type: string
    - default: "true"
      description: Clean out the contents of the destination directory if it already
        exists before cloning.
      name: deleteExisting
      type: string
    - default: ""
      description: HTTP proxy server for non-SSL requests.
      name: httpProxy
      type: string
    - default: ""
      description: HTTPS proxy server for SSL requests.
      name: httpsProxy
      type: string
    - default: ""
      description: Opt out of proxying HTTP/HTTPS requests.
      name: noProxy
      type: string
    - default: "true"
      description: Log the commands that are executed during `git-clone`'s operation.
      name: verbose
      type: string
    - default: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.21.0
      description: The image providing the git-init binary that this Task runs.
      name: gitInitImage
      type: string
    - default: /root
      description: |
        Absolute path to the user's home directory. Set this explicitly if you are running the image as a non-root user or have overridden
        the gitInitImage param with an image containing custom user configuration.
      name: userHome
      type: string
    resources:
      inputs:
      - name: git-source
        optional: true
        type: git
    results:
    - description: The precise commit SHA that was fetched by this Task.
      name: commit
    - description: The precise URL that was fetched by this Task.
      name: url
    steps:
    - env:
      - name: HOME
        value: $(params.userHome)
      - name: PARAM_URL
        value: $(resources.inputs.git-source.url)
      - name: PARAM_REVISION
        value: $(params.revision)
      - name: PARAM_REFSPEC
        value: $(params.refspec)
      - name: PARAM_SUBMODULES
        value: $(params.submodules)
      - name: PARAM_DEPTH
        value: $(params.depth)
      - name: PARAM_SSL_VERIFY
        value: $(params.sslVerify)
      - name: PARAM_SUBDIRECTORY
        value: $(params.subdirectory)
      - name: PARAM_DELETE_EXISTING
        value: $(params.deleteExisting)
      - name: PARAM_HTTP_PROXY
        value: $(params.httpProxy)
      - name: PARAM_HTTPS_PROXY
        value: $(params.httpsProxy)
      - name: PARAM_NO_PROXY
        value: $(params.noProxy)
      - name: PARAM_VERBOSE
        value: $(params.verbose)
      - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
        value: $(params.sparseCheckoutDirectories)
      - name: PARAM_USER_HOME
        value: $(params.userHome)
      - name: WORKSPACE_SOURCE_PATH
        value: $(workspaces.source.path)
      - name: WORKSPACE_SSH_DIRECTORY_BOUND
        value: $(workspaces.ssh-directory.bound)
      - name: WORKSPACE_SSH_DIRECTORY_PATH
        value: $(workspaces.ssh-directory.path)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
        value: $(workspaces.basic-auth.bound)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
        value: $(workspaces.basic-auth.path)
      image: $(params.gitInitImage)
      name: clone
      resources: {}
      script: |
        #!/usr/bin/env sh
        set -eu

        if [ "${PARAM_VERBOSE}" = "true" ] ; then
          set -x
        fi

        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ] ; then
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials" "${PARAM_USER_HOME}/.git-credentials"
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig" "${PARAM_USER_HOME}/.gitconfig"
          chmod 400 "${PARAM_USER_HOME}/.git-credentials"
          chmod 400 "${PARAM_USER_HOME}/.gitconfig"
        fi

        if [ "${WORKSPACE_SSH_DIRECTORY_BOUND}" = "true" ] ; then
          cp -R "${WORKSPACE_SSH_DIRECTORY_PATH}" "${PARAM_USER_HOME}"/.ssh
          chmod 700 "${PARAM_USER_HOME}"/.ssh
          chmod -R 400 "${PARAM_USER_HOME}"/.ssh/*
        fi

        CHECKOUT_DIR="${WORKSPACE_SOURCE_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf ${CHECKOUT_DIR}" because ${CHECKOUT_DIR} might be "/"
          # or the root of a mounted volume.
          if [ -d "${CHECKOUT_DIR}" ] ; then
            # Delete non-hidden files and directories
            rm -rf "${CHECKOUT_DIR:?}"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "${CHECKOUT_DIR}"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "${CHECKOUT_DIR}"/..?*
          fi
        }

        if [ "${PARAM_DELETE_EXISTING}" = "true" ] ; then
          cleandir
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        /ko-app/git-init \
          -url="${PARAM_URL}" \
          -revision="${PARAM_REVISION}" \
          -refspec="${PARAM_REFSPEC}" \
          -path="${CHECKOUT_DIR}" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth="${PARAM_DEPTH}" \
          -sparseCheckoutDirectories="${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "${CHECKOUT_DIR}"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "${EXIT_CODE}" != 0 ] ; then
          exit "${EXIT_CODE}"
        fi
        printf "%s" "${RESULT_SHA}" > "$(results.commit.path)"
        printf "%s" "${PARAM_URL}" > "$(results.url.path)"
    workspaces:
    - description: The git repo will be cloned onto the volume backing this Workspace.
      name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"helm","namespace":"tekton-pipelines"},"spec":{"params":[{"default":"test","name":"IMAGE"},{"default":"test-service","name":"SERVICE_NAME"},{"default":"v1-test","name":"TAG"},{"default":".","name":"CONTEXT_DIR"},{"default":"http://chartmuseum.l21d31708530003.local","name":"HELM_REPO_URL"},{"default":"lab-chartmuseum","name":"HELM_REPO_SECRET"},{"default":"lab-helmrepo","name":"LOCAL_REPO"},{"default":"nexus.l21d31708530003.local:5000/helm:alpine-slim","name":"HELM_IMAGE"},{"default":"ssh://git@git.l21d31708530003.local:22022/LAB.l21d31708530003/lab-devops.git","name":"CHART_TEMPLATE_URL"},{"default":"charts/limits-template-novault","name":"CHART_CONTEXT_DIR"},{"default":"develop","name":"BUILDREVISION"}],"results":[{"description":"helm push information","name":"helm-push"}],"steps":[{"env":[{"name":"BASIC_AUTH_USER","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_USER","name":"$(params.HELM_REPO_SECRET)"}}},{"name":"BASIC_AUTH_PASS","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_PASS","name":"$(params.HELM_REPO_SECRET)"}}}],"image":"$(params.HELM_IMAGE)","name":"helm-create","script":"#!/usr/bin/env bash\nset -e\n\nTOOLS_PATH=\"$(workspaces.source.path)/$(params.CONTEXT_DIR)\"/tools\n\nif [ -f $TOOLS_PATH ]\n  then \n    find . -type d -name '$TOOLS_PATH' | xargs rm\nfi\n\neval $(ssh-agent)\n\nprintf \"Download Helm Chart Template... \\n\"\ngit config --global core.sshCommand 'ssh -o StrictHostKeyChecking=accept-new'\ngit clone -b $(params.BUILDREVISION) $(params.CHART_TEMPLATE_URL) $TOOLS_PATH\n\nprintf \"Customize project Helm Chart... \\n\"\npushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)\n\ngrep -rl '__SERVICE_NAME__' ./ | xargs sed -i 's#__SERVICE_NAME__#$(params.SERVICE_NAME)#g'\n\ngrep -rl '__TAG__' ./ | xargs sed -i 's#__TAG__#$(params.TAG)#g'\n\ngrep -rl '__IMAGE__' ./ | xargs sed -i 's#__IMAGE__#$(params.IMAGE)#g'\n\npopd\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"},{"env":[{"name":"BASIC_AUTH_USER","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_USER","name":"$(params.HELM_REPO_SECRET)"}}},{"name":"BASIC_AUTH_PASS","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_PASS","name":"$(params.HELM_REPO_SECRET)"}}}],"image":"$(params.HELM_IMAGE)","name":"helm-install-in-tmp-ns","script":"#!/usr/bin/env bash\nset -e\n\nTOOLS_PATH=\"$(workspaces.source.path)/$(params.CONTEXT_DIR)\"/tools\n\npushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)\n\nprintf \"Helm Chart Installation in temporary Namespace \\n\"\nhelm upgrade $(params.SERVICE_NAME) . --install --namespace limits-tmp --wait --timeout 600s --debug --recreate-pods --cleanup-on-fail\n\npopd\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"},{"env":[{"name":"BASIC_AUTH_USER","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_USER","name":"$(params.HELM_REPO_SECRET)"}}},{"name":"BASIC_AUTH_PASS","valueFrom":{"secretKeyRef":{"key":"BASIC_AUTH_PASS","name":"$(params.HELM_REPO_SECRET)"}}}],"image":"$(params.HELM_IMAGE)","name":"helm-push","script":"#!/usr/bin/env bash\nset -e\n\nTOOLS_PATH=\"$(workspaces.source.path)/$(params.CONTEXT_DIR)\"/tools\n\npushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)\n\nprintf \"Push Helm Chart into Repository... \\n\"\nhelm push -u $BASIC_AUTH_USER -p $BASIC_AUTH_PASS . $(params.HELM_REPO_URL) -f | tee $(results.helm-push.path)\n\npopd\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"name":"source"}]}}
    creationTimestamp: "2021-07-15T06:52:48Z"
    generation: 12
    name: helm
    namespace: tekton-pipelines
    resourceVersion: "48013658"
    uid: 4d40a9ca-8184-4a0b-bb39-0d0c619e9b22
  spec:
    params:
    - default: test
      name: IMAGE
      type: string
    - default: test-service
      name: SERVICE_NAME
      type: string
    - default: v1-test
      name: TAG
      type: string
    - default: .
      name: CONTEXT_DIR
      type: string
    - default: http://chartmuseum.l21d31708530003.local
      name: HELM_REPO_URL
      type: string
    - default: lab-chartmuseum
      name: HELM_REPO_SECRET
      type: string
    - default: lab-helmrepo
      name: LOCAL_REPO
      type: string
    - default: nexus.l21d31708530003.local:5000/helm:alpine-slim
      name: HELM_IMAGE
      type: string
    - default: ssh://git@git.l21d31708530003.local:22022/LAB.l21d31708530003/lab-devops.git
      name: CHART_TEMPLATE_URL
      type: string
    - default: charts/limits-template-novault
      name: CHART_CONTEXT_DIR
      type: string
    - default: develop
      name: BUILDREVISION
      type: string
    results:
    - description: helm push information
      name: helm-push
    steps:
    - env:
      - name: BASIC_AUTH_USER
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_USER
            name: $(params.HELM_REPO_SECRET)
      - name: BASIC_AUTH_PASS
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_PASS
            name: $(params.HELM_REPO_SECRET)
      image: $(params.HELM_IMAGE)
      name: helm-create
      resources: {}
      script: "#!/usr/bin/env bash\nset -e\n\nTOOLS_PATH=\"$(workspaces.source.path)/$(params.CONTEXT_DIR)\"/tools\n\nif
        [ -f $TOOLS_PATH ]\n  then \n    find . -type d -name '$TOOLS_PATH' | xargs
        rm\nfi\n\neval $(ssh-agent)\n\nprintf \"Download Helm Chart Template... \\n\"\ngit
        config --global core.sshCommand 'ssh -o StrictHostKeyChecking=accept-new'\ngit
        clone -b $(params.BUILDREVISION) $(params.CHART_TEMPLATE_URL) $TOOLS_PATH\n\nprintf
        \"Customize project Helm Chart... \\n\"\npushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)\n\ngrep
        -rl '__SERVICE_NAME__' ./ | xargs sed -i 's#__SERVICE_NAME__#$(params.SERVICE_NAME)#g'\n\ngrep
        -rl '__TAG__' ./ | xargs sed -i 's#__TAG__#$(params.TAG)#g'\n\ngrep -rl '__IMAGE__'
        ./ | xargs sed -i 's#__IMAGE__#$(params.IMAGE)#g'\n\npopd\n"
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    - env:
      - name: BASIC_AUTH_USER
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_USER
            name: $(params.HELM_REPO_SECRET)
      - name: BASIC_AUTH_PASS
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_PASS
            name: $(params.HELM_REPO_SECRET)
      image: $(params.HELM_IMAGE)
      name: helm-install-in-tmp-ns
      resources: {}
      script: |
        #!/usr/bin/env bash
        set -e

        TOOLS_PATH="$(workspaces.source.path)/$(params.CONTEXT_DIR)"/tools

        pushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)

        printf "Helm Chart Installation in temporary Namespace \n"
        helm upgrade $(params.SERVICE_NAME) . --install --namespace limits-tmp --wait --timeout 600s --debug --recreate-pods --cleanup-on-fail

        popd
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    - env:
      - name: BASIC_AUTH_USER
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_USER
            name: $(params.HELM_REPO_SECRET)
      - name: BASIC_AUTH_PASS
        valueFrom:
          secretKeyRef:
            key: BASIC_AUTH_PASS
            name: $(params.HELM_REPO_SECRET)
      image: $(params.HELM_IMAGE)
      name: helm-push
      resources: {}
      script: |
        #!/usr/bin/env bash
        set -e

        TOOLS_PATH="$(workspaces.source.path)/$(params.CONTEXT_DIR)"/tools

        pushd $TOOLS_PATH/$(params.CHART_CONTEXT_DIR)

        printf "Push Helm Chart into Repository... \n"
        helm push -u $BASIC_AUTH_USER -p $BASIC_AUTH_PASS . $(params.HELM_REPO_URL) -f | tee $(results.helm-push.path)

        popd
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"Build and upload container image using Kaniko","tekton.dev/pipelines.minVersion":"0.17.0","tekton.dev/tags":"image-build"},"labels":{"app.kubernetes.io/version":"0.4"},"name":"kaniko","namespace":"tekton-pipelines"},"spec":{"description":"This Task builds source into a container image using Google's kaniko tool.\nKaniko doesn't depend on a Docker daemon and executes each command within a Dockerfile completely in userspace. This enables building container images in environments that can't easily or securely run a Docker daemon, such as a standard Kubernetes cluster.","params":[{"description":"Name (reference) of the image to build.","name":"IMAGE"},{"default":"./Dockerfile","description":"Path to the Dockerfile to build.","name":"DOCKERFILE"},{"default":"./","description":"The build context used by Kaniko.","name":"CONTEXT"},{"default":[],"name":"EXTRA_ARGS","type":"array"},{"default":"gcr.io/kaniko-project/executor:v1.5.1@sha256:c6166717f7fe0b7da44908c986137ecfeab21f31ec3992f6e128fff8a94be8a5","description":"The image on which builds will run (default is v1.5.1)","name":"BUILDER_IMAGE"}],"results":[{"description":"Digest of the image just built.","name":"IMAGE-DIGEST"}],"steps":[{"args":["$(params.EXTRA_ARGS[*])","--dockerfile=$(params.DOCKERFILE)","--context=$(workspaces.source.path)/$(params.CONTEXT)","--destination=$(params.IMAGE)","--oci-layout-path=$(workspaces.source.path)/$(params.CONTEXT)/image-digest"],"image":"$(params.BUILDER_IMAGE)","name":"build-and-push","securityContext":{"runAsUser":0},"workingDir":"$(workspaces.source.path)"},{"args":["-images=[{\"name\":\"$(params.IMAGE)\",\"type\":\"image\",\"url\":\"$(params.IMAGE)\",\"digest\":\"\",\"OutputImageDir\":\"$(workspaces.source.path)/$(params.CONTEXT)/image-digest\"}]","-terminationMessagePath=$(params.CONTEXT)/image-digested"],"command":["/ko-app/imagedigestexporter"],"image":"gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/imagedigestexporter:v0.16.2","name":"write-digest","securityContext":{"runAsUser":0},"workingDir":"$(workspaces.source.path)"},{"image":"docker.io/stedolan/jq@sha256:a61ed0bca213081b64be94c5e1b402ea58bc549f457c2682a86704dd55231e09","name":"digest-to-results","script":"cat $(params.CONTEXT)/image-digested | jq '.[0].value' -rj | tee /tekton/results/IMAGE-DIGEST\n","workingDir":"$(workspaces.source.path)"}],"workspaces":[{"description":"Holds the context and docker file","name":"source"},{"description":"Includes a docker `config.json`","mountPath":"/kaniko/.docker","name":"dockerconfig","optional":true}]}}
      tekton.dev/displayName: Build and upload container image using Kaniko
      tekton.dev/pipelines.minVersion: 0.17.0
      tekton.dev/tags: image-build
    creationTimestamp: "2021-07-10T12:53:02Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.4"
    name: kaniko
    namespace: tekton-pipelines
    resourceVersion: "25871912"
    uid: ebdfe616-3243-4330-9f89-1c3b9fe5c11b
  spec:
    description: |-
      This Task builds source into a container image using Google's kaniko tool.
      Kaniko doesn't depend on a Docker daemon and executes each command within a Dockerfile completely in userspace. This enables building container images in environments that can't easily or securely run a Docker daemon, such as a standard Kubernetes cluster.
    params:
    - description: Name (reference) of the image to build.
      name: IMAGE
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: DOCKERFILE
      type: string
    - default: ./
      description: The build context used by Kaniko.
      name: CONTEXT
      type: string
    - default: []
      name: EXTRA_ARGS
      type: array
    - default: gcr.io/kaniko-project/executor:v1.5.1@sha256:c6166717f7fe0b7da44908c986137ecfeab21f31ec3992f6e128fff8a94be8a5
      description: The image on which builds will run (default is v1.5.1)
      name: BUILDER_IMAGE
      type: string
    results:
    - description: Digest of the image just built.
      name: IMAGE-DIGEST
    steps:
    - args:
      - $(params.EXTRA_ARGS[*])
      - --dockerfile=$(params.DOCKERFILE)
      - --context=$(workspaces.source.path)/$(params.CONTEXT)
      - --destination=$(params.IMAGE)
      - --oci-layout-path=$(workspaces.source.path)/$(params.CONTEXT)/image-digest
      image: $(params.BUILDER_IMAGE)
      name: build-and-push
      resources: {}
      securityContext:
        runAsUser: 0
      workingDir: $(workspaces.source.path)
    - args:
      - -images=[{"name":"$(params.IMAGE)","type":"image","url":"$(params.IMAGE)","digest":"","OutputImageDir":"$(workspaces.source.path)/$(params.CONTEXT)/image-digest"}]
      - -terminationMessagePath=$(params.CONTEXT)/image-digested
      command:
      - /ko-app/imagedigestexporter
      image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/imagedigestexporter:v0.16.2
      name: write-digest
      resources: {}
      securityContext:
        runAsUser: 0
      workingDir: $(workspaces.source.path)
    - image: docker.io/stedolan/jq@sha256:a61ed0bca213081b64be94c5e1b402ea58bc549f457c2682a86704dd55231e09
      name: digest-to-results
      resources: {}
      script: |
        cat $(params.CONTEXT)/image-digested | jq '.[0].value' -rj | tee /tekton/results/IMAGE-DIGEST
      workingDir: $(workspaces.source.path)
    workspaces:
    - description: Holds the context and docker file
      name: source
    - description: Includes a docker `config.json`
      mountPath: /kaniko/.docker
      name: dockerconfig
      optional: true
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"cli"},"labels":{"app.kubernetes.io/version":"0.1"},"name":"kn","namespace":"tekton-pipelines"},"spec":{"description":"This Task performs operations on Knative resources (services, revisions, routes) using kn CLI","params":[{"default":"gcr.io/knative-releases/knative.dev/client/cmd/kn:latest","description":"kn CLI container image to run this task","name":"kn-image"},{"default":["help"],"description":"kn CLI arguments to run","name":"ARGS","type":"array"}],"steps":[{"args":["$(params.ARGS)"],"command":["/ko-app/kn"],"image":"$(params.kn-image)","name":"kn"}]}}
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: cli
    creationTimestamp: "2021-07-07T13:33:14Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
    name: kn
    namespace: tekton-pipelines
    resourceVersion: "23448515"
    uid: be8dd1b9-78fd-4135-aab4-ed91e3e41c88
  spec:
    description: This Task performs operations on Knative resources (services, revisions,
      routes) using kn CLI
    params:
    - default: gcr.io/knative-releases/knative.dev/client/cmd/kn:latest
      description: kn CLI container image to run this task
      name: kn-image
      type: string
    - default:
      - help
      description: kn CLI arguments to run
      name: ARGS
      type: array
    steps:
    - args:
      - $(params.ARGS)
      command:
      - /ko-app/kn
      image: $(params.kn-image)
      name: kn
      resources: {}
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/displayName":"kubernetes actions","tekton.dev/pipelines.minVersion":"0.17.0","tekton.dev/tags":"CLI, kubectl"},"labels":{"app.kubernetes.io/version":"0.2"},"name":"kubernetes-actions","namespace":"tekton-pipelines"},"spec":{"description":"This task is the generic kubectl CLI task which can be used to run all kinds of k8s commands","params":[{"default":"kubectl $@","description":"The Kubernetes CLI script to run","name":"script","type":"string"},{"default":["help"],"description":"The Kubernetes CLI arguments to run","name":"args","type":"array"},{"default":"bitnami/kubectl","description":"Kubectl wrapper image","name":"image"}],"results":[{"description":"some result can be emitted if someone wants to.","name":"output-result"}],"steps":[{"args":["$(params.args)"],"image":"$(params.image)","name":"kubectl","script":"#!/usr/bin/env bash\n\n[[ \"$(workspaces.manifest-dir.bound)\" == \"true\" ]] \u0026\u0026 \\\ncd $(workspaces.manifest-dir.path)\n\n[[ \"$(workspaces.kubeconfig-dir.bound)\" == \"true\" ]] \u0026\u0026 \\\n[[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]] \u0026\u0026 \\\nexport KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig\n\n$(params.script)\n"}],"workspaces":[{"name":"manifest-dir","optional":true},{"name":"kubeconfig-dir","optional":true}]}}
      tekton.dev/displayName: kubernetes actions
      tekton.dev/pipelines.minVersion: 0.17.0
      tekton.dev/tags: CLI, kubectl
    creationTimestamp: "2021-07-07T09:51:53Z"
    generation: 4
    labels:
      app.kubernetes.io/version: "0.2"
    name: kubernetes-actions
    namespace: tekton-pipelines
    resourceVersion: "42281377"
    uid: 975e4979-5339-4229-9028-0f47fe82bb9b
  spec:
    description: This task is the generic kubectl CLI task which can be used to run
      all kinds of k8s commands
    params:
    - default: kubectl $@
      description: The Kubernetes CLI script to run
      name: script
      type: string
    - default:
      - help
      description: The Kubernetes CLI arguments to run
      name: args
      type: array
    - default: bitnami/kubectl
      description: Kubectl wrapper image
      name: image
      type: string
    results:
    - description: some result can be emitted if someone wants to.
      name: output-result
    steps:
    - args:
      - $(params.args)
      image: $(params.image)
      name: kubectl
      resources: {}
      script: |
        #!/usr/bin/env bash

        [[ "$(workspaces.manifest-dir.bound)" == "true" ]] && \
        cd $(workspaces.manifest-dir.path)

        [[ "$(workspaces.kubeconfig-dir.bound)" == "true" ]] && \
        [[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]] && \
        export KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig

        $(params.script)
    workspaces:
    - name: manifest-dir
      optional: true
    - name: kubeconfig-dir
      optional: true
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{"tekton.dev/pipelines.minVersion":"0.12.1","tekton.dev/tags":"build-tool"},"labels":{"app.kubernetes.io/version":"0.2"},"name":"maven","namespace":"tekton-pipelines"},"spec":{"description":"This Task can be used to run a Maven build.","params":[{"default":"gcr.io/cloud-builders/mvn@sha256:57523fc43394d6d9d2414ee8d1c85ed7a13460cbb268c3cd16d28cfb3859e641","description":"Maven base image","name":"MAVEN_IMAGE","type":"string"},{"default":["package"],"description":"maven goals to run","name":"GOALS","type":"array"},{"default":"","description":"The Maven repository mirror url","name":"MAVEN_MIRROR_URL","type":"string"},{"default":"","description":"The username for the server","name":"SERVER_USER","type":"string"},{"default":"","description":"The password for the server","name":"SERVER_PASSWORD","type":"string"},{"default":"","description":"The username for the proxy server","name":"PROXY_USER","type":"string"},{"default":"","description":"The password for the proxy server","name":"PROXY_PASSWORD","type":"string"},{"default":"","description":"Port number for the proxy server","name":"PROXY_PORT","type":"string"},{"default":"","description":"Proxy server Host","name":"PROXY_HOST","type":"string"},{"default":"","description":"Non proxy server host","name":"PROXY_NON_PROXY_HOSTS","type":"string"},{"default":"http","description":"Protocol for the proxy ie http or https","name":"PROXY_PROTOCOL","type":"string"},{"default":".","description":"The context directory within the repository for sources on which we want to execute maven goals.","name":"CONTEXT_DIR","type":"string"}],"steps":[{"image":"registry.access.redhat.com/ubi8/ubi-minimal:8.2","name":"mvn-settings","script":"#!/usr/bin/env bash\n\n[[ -f $(workspaces.maven-settings.path)/settings.xml ]] \u0026\u0026 \\\necho 'using existing $(workspaces.maven-settings.path)/settings.xml' \u0026\u0026 exit 0\n\ncat \u003e $(workspaces.maven-settings.path)/settings.xml \u003c\u003cEOF\n\u003csettings\u003e\n  \u003cservers\u003e\n    \u003c!-- The servers added here are generated from environment variables. Don't change. --\u003e\n    \u003c!-- ### SERVER's USER INFO from ENV ### --\u003e\n  \u003c/servers\u003e\n  \u003cmirrors\u003e\n    \u003c!-- The mirrors added here are generated from environment variables. Don't change. --\u003e\n    \u003c!-- ### mirrors from ENV ### --\u003e\n  \u003c/mirrors\u003e\n  \u003cproxies\u003e\n    \u003c!-- The proxies added here are generated from environment variables. Don't change. --\u003e\n    \u003c!-- ### HTTP proxy from ENV ### --\u003e\n  \u003c/proxies\u003e\n\u003c/settings\u003e\nEOF\n\nxml=\"\"\nif [ -n \"$(params.PROXY_HOST)\" -a -n \"$(params.PROXY_PORT)\" ]; then\n  xml=\"\u003cproxy\u003e\\\n    \u003cid\u003egenproxy\u003c/id\u003e\\\n    \u003cactive\u003etrue\u003c/active\u003e\\\n    \u003cprotocol\u003e$(params.PROXY_PROTOCOL)\u003c/protocol\u003e\\\n    \u003chost\u003e$(params.PROXY_HOST)\u003c/host\u003e\\\n    \u003cport\u003e$(params.PROXY_PORT)\u003c/port\u003e\"\n  if [ -n \"$(params.PROXY_USER)\" -a -n \"$(params.PROXY_PASSWORD)\" ]; then\n    xml=\"$xml\\\n        \u003cusername\u003e$(params.PROXY_USER)\u003c/username\u003e\\\n        \u003cpassword\u003e$(params.PROXY_PASSWORD)\u003c/password\u003e\"\n  fi\n  if [ -n \"$(params.PROXY_NON_PROXY_HOSTS)\" ]; then\n    xml=\"$xml\\\n        \u003cnonProxyHosts\u003e$(params.PROXY_NON_PROXY_HOSTS)\u003c/nonProxyHosts\u003e\"\n  fi\n  xml=\"$xml\\\n      \u003c/proxy\u003e\"\n  sed -i \"s|\u003c!-- ### HTTP proxy from ENV ### --\u003e|$xml|\" $(workspaces.maven-settings.path)/settings.xml\nfi\n\nif [ -n \"$(params.SERVER_USER)\" -a -n \"$(params.SERVER_PASSWORD)\" ]; then\n  xml=\"\u003cserver\u003e\\\n    \u003cid\u003eserverid\u003c/id\u003e\"\n  xml=\"$xml\\\n        \u003cusername\u003e$(params.SERVER_USER)\u003c/username\u003e\\\n        \u003cpassword\u003e$(params.SERVER_PASSWORD)\u003c/password\u003e\"\n  xml=\"$xml\\\n      \u003c/server\u003e\"\n  sed -i \"s|\u003c!-- ### SERVER's USER INFO from ENV ### --\u003e|$xml|\" $(workspaces.maven-settings.path)/settings.xml\nfi\n\nif [ -n \"$(params.MAVEN_MIRROR_URL)\" ]; then\n  xml=\"    \u003cmirror\u003e\\\n    \u003cid\u003emirror.default\u003c/id\u003e\\\n    \u003curl\u003e$(params.MAVEN_MIRROR_URL)\u003c/url\u003e\\\n    \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e\\\n  \u003c/mirror\u003e\"\n  sed -i \"s|\u003c!-- ### mirrors from ENV ### --\u003e|$xml|\" $(workspaces.maven-settings.path)/settings.xml\nfi\n"},{"args":["-s","$(workspaces.maven-settings.path)/settings.xml","$(params.GOALS)"],"command":["/usr/bin/mvn"],"image":"$(params.MAVEN_IMAGE)","name":"mvn-goals","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"description":"The workspace consisting of maven project.","name":"source"},{"description":"The workspace consisting of the custom maven settings provided by the user.","name":"maven-settings"}]}}
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/tags: build-tool
    creationTimestamp: "2021-07-07T14:48:38Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.2"
    name: maven
    namespace: tekton-pipelines
    resourceVersion: "23491349"
    uid: c57b4ee9-325f-4b97-8778-f87d656da404
  spec:
    description: This Task can be used to run a Maven build.
    params:
    - default: gcr.io/cloud-builders/mvn@sha256:57523fc43394d6d9d2414ee8d1c85ed7a13460cbb268c3cd16d28cfb3859e641
      description: Maven base image
      name: MAVEN_IMAGE
      type: string
    - default:
      - package
      description: maven goals to run
      name: GOALS
      type: array
    - default: ""
      description: The Maven repository mirror url
      name: MAVEN_MIRROR_URL
      type: string
    - default: ""
      description: The username for the server
      name: SERVER_USER
      type: string
    - default: ""
      description: The password for the server
      name: SERVER_PASSWORD
      type: string
    - default: ""
      description: The username for the proxy server
      name: PROXY_USER
      type: string
    - default: ""
      description: The password for the proxy server
      name: PROXY_PASSWORD
      type: string
    - default: ""
      description: Port number for the proxy server
      name: PROXY_PORT
      type: string
    - default: ""
      description: Proxy server Host
      name: PROXY_HOST
      type: string
    - default: ""
      description: Non proxy server host
      name: PROXY_NON_PROXY_HOSTS
      type: string
    - default: http
      description: Protocol for the proxy ie http or https
      name: PROXY_PROTOCOL
      type: string
    - default: .
      description: The context directory within the repository for sources on which
        we want to execute maven goals.
      name: CONTEXT_DIR
      type: string
    steps:
    - image: registry.access.redhat.com/ubi8/ubi-minimal:8.2
      name: mvn-settings
      resources: {}
      script: |
        #!/usr/bin/env bash

        [[ -f $(workspaces.maven-settings.path)/settings.xml ]] && \
        echo 'using existing $(workspaces.maven-settings.path)/settings.xml' && exit 0

        cat > $(workspaces.maven-settings.path)/settings.xml <<EOF
        <settings>
          <servers>
            <!-- The servers added here are generated from environment variables. Don't change. -->
            <!-- ### SERVER's USER INFO from ENV ### -->
          </servers>
          <mirrors>
            <!-- The mirrors added here are generated from environment variables. Don't change. -->
            <!-- ### mirrors from ENV ### -->
          </mirrors>
          <proxies>
            <!-- The proxies added here are generated from environment variables. Don't change. -->
            <!-- ### HTTP proxy from ENV ### -->
          </proxies>
        </settings>
        EOF

        xml=""
        if [ -n "$(params.PROXY_HOST)" -a -n "$(params.PROXY_PORT)" ]; then
          xml="<proxy>\
            <id>genproxy</id>\
            <active>true</active>\
            <protocol>$(params.PROXY_PROTOCOL)</protocol>\
            <host>$(params.PROXY_HOST)</host>\
            <port>$(params.PROXY_PORT)</port>"
          if [ -n "$(params.PROXY_USER)" -a -n "$(params.PROXY_PASSWORD)" ]; then
            xml="$xml\
                <username>$(params.PROXY_USER)</username>\
                <password>$(params.PROXY_PASSWORD)</password>"
          fi
          if [ -n "$(params.PROXY_NON_PROXY_HOSTS)" ]; then
            xml="$xml\
                <nonProxyHosts>$(params.PROXY_NON_PROXY_HOSTS)</nonProxyHosts>"
          fi
          xml="$xml\
              </proxy>"
          sed -i "s|<!-- ### HTTP proxy from ENV ### -->|$xml|" $(workspaces.maven-settings.path)/settings.xml
        fi

        if [ -n "$(params.SERVER_USER)" -a -n "$(params.SERVER_PASSWORD)" ]; then
          xml="<server>\
            <id>serverid</id>"
          xml="$xml\
                <username>$(params.SERVER_USER)</username>\
                <password>$(params.SERVER_PASSWORD)</password>"
          xml="$xml\
              </server>"
          sed -i "s|<!-- ### SERVER's USER INFO from ENV ### -->|$xml|" $(workspaces.maven-settings.path)/settings.xml
        fi

        if [ -n "$(params.MAVEN_MIRROR_URL)" ]; then
          xml="    <mirror>\
            <id>mirror.default</id>\
            <url>$(params.MAVEN_MIRROR_URL)</url>\
            <mirrorOf>central</mirrorOf>\
          </mirror>"
          sed -i "s|<!-- ### mirrors from ENV ### -->|$xml|" $(workspaces.maven-settings.path)/settings.xml
        fi
    - args:
      - -s
      - $(workspaces.maven-settings.path)/settings.xml
      - $(params.GOALS)
      command:
      - /usr/bin/mvn
      image: $(params.MAVEN_IMAGE)
      name: mvn-goals
      resources: {}
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - description: The workspace consisting of maven project.
      name: source
    - description: The workspace consisting of the custom maven settings provided
        by the user.
      name: maven-settings
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"newman","namespace":"tekton-pipelines"},"spec":{"description":"Task for running Postman api tests.\nINFO: newman-env.json must be created as newman-env configMap before running the Task.","params":[{"description":"The collection to run, remote URL or local PATH","name":"COLLECTION","type":"string"},{"default":"postman","description":"postman collection location path","name":"CLLECTION_DIR"},{"default":"newman-env","description":"ex newman-env configmap","name":"ENV_CM"},{"default":"newman-env.json","description":"envivronment file name","name":"ENV_FILE"}],"steps":[{"args":["run","$(inputs.params.COLLECTION)","-e","/config/$(inputs.params.ENV_FILE)","--insecure","-k","--bail"],"command":["newman"],"image":"docker.io/postman/newman:latest","name":"run-collections","volumeMounts":[{"mountPath":"/config","name":"$(params.ENV_CM)"}],"workingDir":"$(workspaces.source.path)/$(params.CLLECTION_DIR)"}],"volumes":[{"configMap":{"name":"$(params.ENV_CM)"},"name":"$(params.ENV_CM)"}],"workspaces":[{"name":"source"}]}}
    creationTimestamp: "2021-07-29T08:38:30Z"
    generation: 3
    name: newman
    namespace: tekton-pipelines
    resourceVersion: "47991834"
    uid: b10ba5e3-5125-4c40-a234-25300ed508c9
  spec:
    description: |-
      Task for running Postman api tests.
      INFO: newman-env.json must be created as newman-env configMap before running the Task.
    params:
    - description: The collection to run, remote URL or local PATH
      name: COLLECTION
      type: string
    - default: postman
      description: postman collection location path
      name: CLLECTION_DIR
      type: string
    - default: newman-env
      description: ex newman-env configmap
      name: ENV_CM
      type: string
    - default: newman-env.json
      description: envivronment file name
      name: ENV_FILE
      type: string
    steps:
    - args:
      - run
      - $(inputs.params.COLLECTION)
      - -e
      - /config/$(inputs.params.ENV_FILE)
      - --insecure
      - -k
      - --bail
      command:
      - newman
      image: docker.io/postman/newman:latest
      name: run-collections
      resources: {}
      volumeMounts:
      - mountPath: /config
        name: $(params.ENV_CM)
      workingDir: $(workspaces.source.path)/$(params.CLLECTION_DIR)
    volumes:
    - configMap:
        name: $(params.ENV_CM)
      name: $(params.ENV_CM)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"npm","namespace":"tekton-pipelines"},"spec":{"params":[{"default":".","description":"The path where package.json of the project is defined.","name":"CONTEXT_DIR","type":"string"},{"default":"node:14.17.3-slim","description":"The node image you want to use.","name":"IMAGE_NPM","type":"string"},{"default":"https://alm-npmjs.misys.global.ad/nexus/repository/npm_group/","description":"npm registry used for downloading prereqs","name":"REGISTRY_NPM"}],"steps":[{"env":[{"name":"CI","value":"true"}],"image":"$(params.IMAGE_NPM)","name":"npm-config-install","script":"npm config --global set prefix $(workspaces.source.path)/$(params.CONTEXT_DIR)\nnpm config --global set strict-ssl false\nnpm config --global set registry $(params.REGISTRY_NPM)\nnpm --registry=$(params.REGISTRY_NPM) install\nnpm fund\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"},{"image":"$(params.IMAGE_NPM)","name":"npm-build","script":"npm run build\n","workingDir":"$(workspaces.source.path)/$(params.CONTEXT_DIR)"}],"workspaces":[{"description":"shared pvc for providing access to other tasks input/output","name":"source"}]}}
    creationTimestamp: "2021-07-16T09:43:11Z"
    generation: 70
    name: npm
    namespace: tekton-pipelines
    resourceVersion: "35132560"
    uid: 0fd8cfb2-de65-47d4-8a11-3de75eca13dc
  spec:
    params:
    - default: .
      description: The path where package.json of the project is defined.
      name: CONTEXT_DIR
      type: string
    - default: node:14.17.3-slim
      description: The node image you want to use.
      name: IMAGE_NPM
      type: string
    - default: https://alm-npmjs.misys.global.ad/nexus/repository/npm_group/
      description: npm registry used for downloading prereqs
      name: REGISTRY_NPM
      type: string
    steps:
    - env:
      - name: CI
        value: "true"
      image: $(params.IMAGE_NPM)
      name: npm-config-install
      resources: {}
      script: |
        npm config --global set prefix $(workspaces.source.path)/$(params.CONTEXT_DIR)
        npm config --global set strict-ssl false
        npm config --global set registry $(params.REGISTRY_NPM)
        npm --registry=$(params.REGISTRY_NPM) install
        npm fund
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    - image: $(params.IMAGE_NPM)
      name: npm-build
      resources: {}
      script: |
        npm run build
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR)
    workspaces:
    - description: shared pvc for providing access to other tasks input/output
      name: source
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"source-lister","namespace":"tekton-pipelines"},"spec":{"params":[{"default":"quarkus","description":"The context directory within the repository for sources","name":"contextDir"}],"resources":{"inputs":[{"name":"source","type":"git"}]},"steps":[{"command":["ls","-ltr","/workspace/source/$(inputs.params.contextDir)"],"image":"busybox","name":"ls-build-sources"}]}}
    creationTimestamp: "2021-07-06T14:02:53Z"
    generation: 1
    name: source-lister
    namespace: tekton-pipelines
    resourceVersion: "22651699"
    uid: f6dc8934-9e0b-4468-86b7-b0b8aaaecb9d
  spec:
    params:
    - default: quarkus
      description: The context directory within the repository for sources
      name: contextDir
      type: string
    resources:
      inputs:
      - name: source
        type: git
    steps:
    - command:
      - ls
      - -ltr
      - /workspace/source/$(inputs.params.contextDir)
      image: busybox
      name: ls-build-sources
      resources: {}
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1beta1","kind":"Task","metadata":{"annotations":{},"name":"task-check-optional-resources","namespace":"tekton-pipelines"},"spec":{"resources":{"inputs":[{"name":"git-repo","optional":true,"type":"git"}]},"steps":[{"args":["-c","ls -la /workspace/git-repo"],"command":["bash"],"image":"bitnami/minideb","name":"test"}]}}
    creationTimestamp: "2021-07-08T13:51:28Z"
    generation: 5
    name: task-check-optional-resources
    namespace: tekton-pipelines
    resourceVersion: "24276525"
    uid: 0dd97677-676a-49e8-bca8-11de53923593
  spec:
    resources:
      inputs:
      - name: git-repo
        optional: true
        type: git
    steps:
    - args:
      - -c
      - ls -la /workspace/git-repo
      command:
      - bash
      image: bitnami/minideb
      name: test
      resources: {}
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
